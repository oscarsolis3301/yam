<script>
// Daily Ticket Closures JavaScript - INSTANT LOADING OPTIMIZED
let userTicketsChart = null;
let realUsers = [];
let syncStatus = null;
let ticketDataCache = {
    data: null,
    lastUpdate: 0,
    cacheDuration: 300000 // 5 minutes cache
};

// Global period tracking for accurate data display
let currentPeriod = 'today';

// Global debug function for troubleshooting period issues
window.debugYAMPeriod = function() {
    console.log('üîç YAM Period Debug Info:');
    console.log(`üìÖ Global currentPeriod: ${currentPeriod}`);
    console.log(`üîç Active time button:`, document.querySelector('.user-tickets-card .time-btn.active')?.getAttribute('data-period'));
    console.log(`üìä Chart data:`, userTicketsChart?.data);
    console.log(`üìä Chart labels:`, userTicketsChart?.data?.labels);
    console.log(`üìä Chart dataset:`, userTicketsChart?.data?.datasets?.[0]?.data);
    return {
        currentPeriod: currentPeriod,
        activeButton: document.querySelector('.user-tickets-card .time-btn.active')?.getAttribute('data-period'),
        chartData: userTicketsChart?.data
    };
};

// Global test function for testing user ticket details API
window.testUserTicketDetails = function(username, period = 'today') {
    console.log(`üß™ Testing user ticket details for ${username} with period ${period}`);
    
    const today = new Date();
    let targetDate;
    
    if (period === 'today') {
        targetDate = today.toISOString().split('T')[0];
    } else if (period === 'yesterday') {
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);
        targetDate = yesterday.toISOString().split('T')[0];
    } else {
        targetDate = today.toISOString().split('T')[0];
    }
    
    const apiUrl = `/api/tickets/user-details/${encodeURIComponent(username)}?date=${targetDate}&period=${period}`;
    console.log(`üåê Testing API call: ${apiUrl}`);
    
    fetch(apiUrl)
        .then(response => response.json())
        .then(data => {
            console.log(`üìä API Response for ${username} (${period}):`, data);
            if (data.success) {
                console.log(`‚úÖ Found ${data.total_tickets} tickets for ${username} in ${period}`);
            } else {
                console.log(`‚ùå API Error: ${data.error}`);
            }
        })
        .catch(error => {
            console.error(`‚ùå Fetch Error:`, error);
        });
};

// Preload data immediately when script loads
let preloadedData = null;
let chartInitialized = false;

// ENHANCED CHART STABILITY: Chart data backup and recovery system
let chartDataBackup = {
    labels: [],
    data: [],
    lastBackup: 0,
    backupInterval: 30000 // Backup every 30 seconds
};

// Chart stability monitoring
let chartStabilityMonitor = {
    lastValidData: null,
    consecutiveFailures: 0,
    maxFailures: 3,
    recoveryAttempts: 0,
    maxRecoveryAttempts: 5
};

// Cache invalidation function
function invalidateTicketCache() {
    console.log('üîÑ Invalidating ticket closure cache...');
    localStorage.removeItem('yam_ticket_closures_cache');
    localStorage.removeItem('yam_ticket_closures_cache_previous');
    ticketDataCache.data = null;
    ticketDataCache.lastUpdate = 0;
    console.log('‚úÖ Ticket closure cache cleared');
}

// Immediate data preloading - start before DOM is ready
(function() {
    console.log('üöÄ Preloading ticket closure data for instant chart display...');
    
    // Check if cache was recently invalidated by leaderboard sync
    const lastInvalidation = localStorage.getItem('yam_cache_last_invalidation');
    const now = Date.now();
    if (lastInvalidation && (now - parseInt(lastInvalidation)) < 60000) { // Within last minute
        console.log('üîÑ Cache recently invalidated by leaderboard sync, fetching fresh data');
        invalidateTicketCache();
    }
    
    // Check if we're near the top of the hour (when leaderboard sync runs)
    const currentMinute = new Date().getMinutes();
    if (currentMinute >= 0 && currentMinute <= 2) {
        console.log('üîÑ Near leaderboard sync time, ensuring fresh data');
        // Force fresh data fetch if we're near sync time
        setTimeout(() => {
            updateDailyClosuresData();
        }, 1000); // Wait 1 second then fetch fresh data
    }
    
    // Try to get cached data from localStorage first
    const cachedData = localStorage.getItem('yam_ticket_closures_cache');
    if (cachedData) {
        try {
            const parsed = JSON.parse(cachedData);
            const cacheAge = Date.now() - parsed.timestamp;
            
            // Use cache if it's less than 30 seconds old (much shorter to prevent stale data)
            if (cacheAge < 30000) {
                preloadedData = parsed.data;
                console.log('‚úÖ Using cached data for instant display:', preloadedData);
            }
        } catch (e) {
            console.log('‚ö†Ô∏è Invalid cache data, will fetch fresh');
        }
    }
    
    // Always fetch fresh data in background
    fetch('/api/tickets/closures/today')
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                preloadedData = data;
                // Cache the fresh data
                localStorage.setItem('yam_ticket_closures_cache', JSON.stringify({
                    data: data,
                    timestamp: Date.now()
                }));
                console.log('‚úÖ Fresh data preloaded:', data);
                
                // Update chart if already initialized
                if (chartInitialized && userTicketsChart) {
                    updateChartWithData(data);
                }
                
                // Check if this data is significantly different from cached data
                const cachedData = localStorage.getItem('yam_ticket_closures_cache_previous');
                if (cachedData) {
                    try {
                        const previous = JSON.parse(cachedData);
                        if (previous.data && previous.data.total_closed !== data.total_closed) {
                            console.log('üîÑ Data has changed, forcing chart update');
                            // Force immediate chart update with new data
                            setTimeout(() => {
                                if (userTicketsChart) {
                                    updateChartWithData(data);
                                }
                            }, 100);
                        }
                    } catch (e) {
                        console.log('‚ö†Ô∏è Error comparing cached data:', e);
                    }
                }
                
                // Store current data as previous for next comparison
                localStorage.setItem('yam_ticket_closures_cache_previous', JSON.stringify({
                    data: data,
                    timestamp: Date.now()
                }));
            }
        })
        .catch(error => {
            console.log('‚ö†Ô∏è Preload failed, will use cached or empty data:', error);
        });
})();

document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ YAM User Tickets Scripts - DOM Content Loaded');
    initializeDailyClosures();
    
    // ENHANCED STABILITY: Set up chart stability monitoring
    setupChartStabilityMonitoring();
    
    // Set up time control button event listeners
    setupTimeControlListeners();
    
    // Set up WebSocket listener for leaderboard sync events
    setupLeaderboardSyncListener();
});

function setupTimeControlListeners() {
    // Add click event listeners to time control buttons
    document.querySelectorAll('.user-tickets-card .time-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const period = this.getAttribute('data-period');
            console.log(`üïí Time control button clicked: ${period}`);
            filterDailyClosures(period);
        });
    });
    
    console.log('‚úÖ Time control listeners set up');
}

function setupLeaderboardSyncListener() {
    // Check if SocketIO is available
    if (typeof io !== 'undefined') {
        try {
            const socket = io();
            
            // Listen for leaderboard sync completion events
            socket.on('leaderboard_sync_complete', function(data) {
                console.log('üîÑ Leaderboard sync completed, invalidating cache...');
                invalidateTicketCache();
                updateDailyClosuresData(); // Force fresh data fetch
                
                // Hide sync indicator
                hideSyncIndicator();
                
                // Show notification to user
                showToast('üîÑ Ticket data updated from leaderboard sync!', 'success');
            });
            
            // Listen for cache invalidation events
            socket.on('ticket_cache_invalidated', function(data) {
                console.log('üîÑ Cache invalidation event received...');
                invalidateTicketCache();
                updateDailyClosuresData(); // Force fresh data fetch
            });
            
            console.log('‚úÖ WebSocket listener for leaderboard sync events set up');
        } catch (e) {
            console.log('‚ö†Ô∏è WebSocket setup failed, using polling fallback:', e);
        }
    } else {
        console.log('‚ö†Ô∏è SocketIO not available, using polling for cache invalidation');
    }
}

function setupChartStabilityMonitoring() {
    // Monitor chart data every 10 seconds
    setInterval(() => {
        monitorChartStability();
    }, 10000);
    
    // Backup chart data every 30 seconds
    setInterval(() => {
        backupChartData();
    }, 30000);
    
    // Attempt chart recovery every 60 seconds if needed
    setInterval(() => {
        attemptChartRecovery();
    }, 60000);
}

function monitorChartStability() {
    if (!userTicketsChart) return;
    
    const currentLabels = userTicketsChart.data.labels || [];
    const currentData = userTicketsChart.data.datasets[0]?.data || [];
    
    // Check if chart has valid data
    const hasValidData = currentLabels.length > 0 && currentData.length > 0 && 
                        currentData.some(value => value > 0);
    
    if (hasValidData) {
        // Chart is healthy, reset failure counter
        chartStabilityMonitor.consecutiveFailures = 0;
        chartStabilityMonitor.lastValidData = {
            labels: [...currentLabels],
            data: [...currentData]
        };
        console.log('‚úÖ Chart stability check passed');
    } else {
        // Chart data is invalid
        chartStabilityMonitor.consecutiveFailures++;
        console.warn(`‚ö†Ô∏è Chart stability check failed (${chartStabilityMonitor.consecutiveFailures}/${chartStabilityMonitor.maxFailures})`);
        
        // If we have too many consecutive failures, trigger recovery
        if (chartStabilityMonitor.consecutiveFailures >= chartStabilityMonitor.maxFailures) {
            console.error('üö® Chart stability threshold exceeded, triggering recovery...');
            triggerChartRecovery();
        }
    }
}

function backupChartData() {
    if (!userTicketsChart) return;
    
    const currentLabels = userTicketsChart.data.labels || [];
    const currentData = userTicketsChart.data.datasets[0]?.data || [];
    
    // Only backup if we have valid data
    if (currentLabels.length > 0 && currentData.length > 0) {
        chartDataBackup.labels = [...currentLabels];
        chartDataBackup.data = [...currentData];
        chartDataBackup.lastBackup = Date.now();
        console.log('üíæ Chart data backed up:', chartDataBackup);
    }
}

function triggerChartRecovery() {
    if (chartStabilityMonitor.recoveryAttempts >= chartStabilityMonitor.maxRecoveryAttempts) {
        console.error('üö® Maximum recovery attempts reached, chart may be permanently broken');
        return;
    }
    
    chartStabilityMonitor.recoveryAttempts++;
    console.log(`üîÑ Attempting chart recovery (${chartStabilityMonitor.recoveryAttempts}/${chartStabilityMonitor.maxRecoveryAttempts})`);
    
    // Try multiple recovery strategies
    attemptChartRecovery();
}

function attemptChartRecovery() {
    if (!userTicketsChart) {
        console.log('üìä Chart not initialized, skipping recovery');
        return;
    }
    
    console.log('üîÑ Attempting chart recovery...');
    
    // Strategy 1: Try to restore from backup
    if (chartDataBackup.labels.length > 0 && chartDataBackup.data.length > 0) {
        console.log('üìä Restoring chart from backup data...');
        userTicketsChart.data.labels = [...chartDataBackup.labels];
        userTicketsChart.data.datasets[0].data = [...chartDataBackup.data];
        userTicketsChart.update('none'); // Use 'none' to prevent zoom changes
        
        // Check if recovery was successful
        setTimeout(() => {
            const recoveredLabels = userTicketsChart.data.labels || [];
            const recoveredData = userTicketsChart.data.datasets[0]?.data || [];
            
            if (recoveredLabels.length > 0 && recoveredData.length > 0) {
                console.log('‚úÖ Chart recovery successful from backup');
                chartStabilityMonitor.consecutiveFailures = 0;
                chartStabilityMonitor.recoveryAttempts = 0;
                hideChartLoading();
                return;
            }
        }, 100);
    }
    
    // Strategy 2: Try to restore from last valid data
    if (chartStabilityMonitor.lastValidData) {
        console.log('üìä Restoring chart from last valid data...');
        userTicketsChart.data.labels = [...chartStabilityMonitor.lastValidData.labels];
        userTicketsChart.data.datasets[0].data = [...chartStabilityMonitor.lastValidData.data];
        userTicketsChart.update('none'); // Use 'none' to prevent zoom changes
        
        setTimeout(() => {
            const recoveredLabels = userTicketsChart.data.labels || [];
            const recoveredData = userTicketsChart.data.datasets[0]?.data || [];
            
            if (recoveredLabels.length > 0 && recoveredData.length > 0) {
                console.log('‚úÖ Chart recovery successful from last valid data');
                chartStabilityMonitor.consecutiveFailures = 0;
                chartStabilityMonitor.recoveryAttempts = 0;
                hideChartLoading();
                return;
            }
        }, 100);
    }
    
    // Strategy 3: Fetch fresh data from API
    console.log('üìä Fetching fresh data for chart recovery...');
    fetch('/api/tickets/closures/today')
        .then(response => response.json())
        .then(data => {
            if (data.success && data.labels && data.data) {
                console.log('‚úÖ Fresh data received, updating chart...');
                updateChartWithData(data);
                chartStabilityMonitor.consecutiveFailures = 0;
                chartStabilityMonitor.recoveryAttempts = 0;
            } else {
                throw new Error('Invalid API response');
            }
        })
        .catch(error => {
            console.error('‚ùå Chart recovery failed:', error);
            
            // Strategy 4: Use fallback dummy data as last resort
            console.log('üìä Using fallback dummy data for chart recovery...');
            const fallbackLabels = ['User 1', 'User 2', 'User 3', 'User 4', 'User 5'];
            const fallbackData = [5, 3, 7, 2, 4];
            
            userTicketsChart.data.labels = fallbackLabels;
            userTicketsChart.data.datasets[0].data = fallbackData;
            userTicketsChart.update('none'); // Use 'none' to prevent zoom changes
            
            console.log('‚ö†Ô∏è Chart recovered with fallback data');
            chartStabilityMonitor.consecutiveFailures = 0;
            chartStabilityMonitor.recoveryAttempts = 0;
            hideChartLoading();
        });
}

function initializeDailyClosures() {
    console.log('üöÄ Initializing Daily Closures with instant loading...');
    
    // Check if chart container exists
    const chartContainer = document.querySelector('.user-tickets-chart.enhanced');
    if (chartContainer) {
        console.log('‚úÖ Chart container found:', chartContainer);
        console.log('üìä Container dimensions:', chartContainer.offsetWidth, 'x', chartContainer.offsetHeight);
    } else {
        console.error('‚ùå Chart container not found!');
    }
    
    loadRealUsers();
    initializeDailyClosuresChart();
    
    // Update data immediately if we have preloaded data
    if (preloadedData) {
        console.log('‚ö° Using preloaded data for instant display');
        updateChartWithData(preloadedData);
        updateDailyClosuresStatsFromData(preloadedData);
        updateTopPerformers(preloadedData);
        
        // Hide loading overlay immediately if we have data
        hideChartLoading();
    } else {
        // Fallback to API call - immediate
        updateDailyClosuresData();
        updateDailyClosuresStats();
        checkSyncStatus();
    }
    
    // Set up optimized refresh intervals with caching
    setInterval(updateDailyClosuresData, 3600000); // Update every 60 minutes
    setInterval(updateDailyClosuresStats, 7200000); // Update stats every 2 hours
    setInterval(checkSyncStatus, 1200000); // Check sync status every 20 minutes
    
    // Check for cache invalidation every 30 seconds
    setInterval(checkForCacheInvalidation, 30000);
    
    // Start persistent timer countdown display
    startPersistentTimerCountdown();
}

function loadRealUsers() {
    // Fetch real users from the API
    fetch('/api/users')
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to fetch users');
            }
            return response.json();
        })
        .then(data => {
            // Handle different response formats
            const users = data.users || data || [];
            realUsers = users.map(user => ({
                id: user.id || user.username,
                username: user.username,
                email: user.email,
                role: user.role || 'User',
                profile_picture: user.profile_picture
            }));
            
            console.log('‚úÖ Loaded real users:', realUsers.length);
        })
        .catch(error => {
            console.error('Error loading users:', error);
            realUsers = [];
            console.log('‚ö†Ô∏è No fallback users loaded - will rely on ticket closures API for real data');
        });
}

function initializeDailyClosuresChart() {
    // Check if Chart.js is available
    if (typeof Chart === 'undefined') {
        console.error('‚ùå Chart.js not loaded! Waiting for it to load...');
        setTimeout(initializeDailyClosuresChart, 100);
        return;
    }
    
    const canvas = document.getElementById('userTicketsChart');
    if (!canvas) {
        console.error('‚ùå Chart canvas not found!');
        return;
    }
    
    // Ensure canvas has proper dimensions
    const container = canvas.parentElement;
    if (container) {
        // Set fixed dimensions to prevent zoom changes
        const containerWidth = container.offsetWidth || 800;
        const containerHeight = container.offsetHeight || 400;
        
        // Set fixed canvas dimensions to prevent resizing
        canvas.style.width = containerWidth + 'px';
        canvas.style.height = containerHeight + 'px';
        canvas.style.maxWidth = containerWidth + 'px';
        canvas.style.maxHeight = containerHeight + 'px';
        canvas.style.minWidth = containerWidth + 'px';
        canvas.style.minHeight = containerHeight + 'px';
        
        // Set canvas resolution to match display size
        canvas.width = containerWidth;
        canvas.height = containerHeight;
        
        console.log('üìä Chart container dimensions:', containerWidth, 'x', containerHeight);
        
        // Ensure container is visible and has dimensions
        if (container.offsetWidth === 0 || container.offsetHeight === 0) {
            console.log('‚ö†Ô∏è Container has no dimensions, waiting for layout...');
            setTimeout(initializeDailyClosuresChart, 50);
            return;
        }
    }
    
    const ctx = canvas.getContext('2d');
    console.log('üìä Initializing chart with canvas:', canvas);
    console.log('üìä Canvas dimensions:', canvas.width, 'x', canvas.height);
    
    // Use preloaded data if available, otherwise use empty data
    const initialData = preloadedData ? {
        labels: preloadedData.labels || [],
        today: preloadedData.data || []
    } : generateDailyClosuresData();
    
    console.log('üìä Creating chart with initial data:', initialData);
    
    userTicketsChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: initialData.labels,
            datasets: [{
                label: 'Closed Today',
                data: initialData.today,
                backgroundColor: 'rgba(139, 92, 246, 0.9)',
                borderColor: 'rgba(139, 92, 246, 0.9)',
                borderWidth: 0,
                borderRadius: 6,
                borderSkipped: false,
                hoverBackgroundColor: 'rgba(139, 92, 246, 1)',
                hoverBorderColor: 'rgba(139, 92, 246, 1)',
                hoverBorderWidth: 0,
            }]
        },
        options: {
            responsive: false, // Prevent automatic resizing that causes zoom changes
            maintainAspectRatio: false,
            indexAxis: 'x', // Ensure horizontal bar chart
            layout: {
                padding: {
                    top: 10,
                    bottom: 10,
                    left: 10,
                    right: 10
                }
            },
            elements: {
                bar: {
                    borderWidth: 0,
                }
            },
            interaction: {
                intersect: false,
                mode: 'index'
            },
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    backgroundColor: 'rgba(15, 15, 15, 0.95)',
                    titleColor: '#ffffff',
                    bodyColor: '#cccccc',
                    borderColor: 'rgba(255, 255, 255, 0.1)',
                    borderWidth: 1,
                    cornerRadius: 8,
                    displayColors: false,
                    callbacks: {
                        title: function(context) {
                            return context[0].label;
                        },
                        label: function(context) {
                            return `Closed Today: ${context.parsed.y} tickets`;
                        },
                        afterLabel: function(context) {
                            return 'Click to view details';
                        }
                    }
                }
            },
            scales: {
                x: {
                    grid: {
                        display: false
                    },
                    ticks: {
                        color: '#666666',
                        font: {
                            size: 12
                        },
                        maxRotation: 45, // Rotate labels if needed
                        minRotation: 0
                    }
                },
                y: {
                    beginAtZero: true,
                    grid: {
                        color: 'rgba(255, 255, 255, 0.05)'
                    },
                    ticks: {
                        color: '#666666',
                        font: {
                            size: 12
                        },
                        stepSize: 1 // Ensure integer steps
                    }
                }
            },
            onClick: function(event, elements) {
                if (elements.length > 0) {
                    const element = elements[0];
                    const username = this.data.labels[element.index];
                    const ticketCount = this.data.datasets[0].data[element.index];
                    
                    console.log(`üéØ User clicked on ${username} with ${ticketCount} tickets`);
                    console.log(`üìÖ Current period when clicked: ${currentPeriod}`);
                    showUserTicketDetails(username, ticketCount);
                }
            }
        }
    });
    
    chartInitialized = true;
    console.log('‚úÖ Chart initialized successfully');
    
    // Prevent automatic resizing that causes zoom changes
    if (userTicketsChart.resize) {
        const originalResize = userTicketsChart.resize;
        userTicketsChart.resize = function() {
            console.log('üö´ Chart resize blocked to prevent zoom changes');
            // Don't call the original resize function
            return;
        };
    }
    
    // If we have preloaded data, update immediately
    if (preloadedData) {
        console.log('‚ö° Updating chart with preloaded data immediately');
        updateChartWithData(preloadedData);
    } else {
        // Show loading if no preloaded data
        showChartLoading();
    }
}

function generateDailyClosuresData() {
    // Return empty data initially - will be populated by real API data
    return { labels: [], today: [] };
}

function showChartLoading() {
    const loadingOverlay = document.getElementById('chartLoadingOverlay');
    if (loadingOverlay) {
        loadingOverlay.style.display = 'flex';
        loadingOverlay.classList.remove('hidden');
    }
}

function hideChartLoading() {
    const loadingOverlay = document.getElementById('chartLoadingOverlay');
    if (loadingOverlay) {
        loadingOverlay.classList.add('hidden');
        setTimeout(() => {
            loadingOverlay.style.display = 'none';
        }, 300);
    }
}

// ENHANCED CHART UPDATE FUNCTION: Robust data handling with stability checks
function updateChartWithData(data) {
    if (!userTicketsChart) {
        console.warn('‚ö†Ô∏è Chart not initialized yet');
        return;
    }
    
    console.log('üìä Updating chart with data:', data);
    
    const labels = data.labels || [];
    const chartData = data.data || [];
    
    // ENHANCED STABILITY: Validate data before updating chart
    if (labels.length > 0 && chartData.length > 0 && labels.length === chartData.length) {
        // ENHANCED STABILITY: Create deep copies to prevent data corruption
        const safeLabels = [...labels];
        const safeData = [...chartData];
        
        // ENHANCED STABILITY: Ensure all data values are valid numbers
        const validatedData = safeData.map(value => {
            const numValue = Number(value);
            return isNaN(numValue) ? 0 : Math.max(0, numValue);
        });
        
        console.log('üìä Validated data:', { labels: safeLabels, data: validatedData });
        
        // ENHANCED STABILITY: Update chart with validated data
        try {
            userTicketsChart.data.labels = safeLabels;
            userTicketsChart.data.datasets[0].data = validatedData;
            userTicketsChart.update('none'); // Use 'none' to prevent animations that cause zoom
            
            console.log('‚úÖ Chart updated successfully with data');
            console.log('   Chart now shows', safeLabels.length, 'users with bars');
            
            // ENHANCED STABILITY: Update backup data after successful update
            chartDataBackup.labels = [...safeLabels];
            chartDataBackup.data = [...validatedData];
            chartDataBackup.lastBackup = Date.now();
            
            // ENHANCED STABILITY: Reset stability monitor after successful update
            chartStabilityMonitor.consecutiveFailures = 0;
            chartStabilityMonitor.lastValidData = {
                labels: [...safeLabels],
                data: [...validatedData]
            };
            
            // Hide loading overlay
            hideChartLoading();
            
            // ENHANCED STABILITY: Update chart without unnecessary resizing
            setTimeout(() => {
                if (userTicketsChart) {
                    try {
                        // Only update the chart data, don't resize unnecessarily
                        userTicketsChart.update('none'); // Use 'none' to prevent animation
                        console.log('üìä Chart updated without resizing');
                        
                        // ENHANCED STABILITY: Verify chart is still stable
                        setTimeout(() => {
                            verifyChartStability();
                        }, 50);
                    } catch (updateError) {
                        console.warn('‚ö†Ô∏è Chart update failed:', updateError);
                    }
                }
            }, 10);
            
        } catch (updateError) {
            console.error('‚ùå Chart update failed:', updateError);
            
            // ENHANCED STABILITY: Attempt recovery if update fails
            console.log('üîÑ Attempting chart recovery after update failure...');
            triggerChartRecovery();
        }
    } else {
        console.warn('‚ö†Ô∏è No valid data to display in chart');
        console.log('üìä Data validation failed:', { 
            labelsLength: labels.length, 
            dataLength: chartData.length,
            labelsMatch: labels.length === chartData.length 
        });
        
        // ENHANCED STABILITY: Don't clear chart data if we have backup data
        if (chartDataBackup.labels.length > 0 && chartDataBackup.data.length > 0) {
            console.log('üìä Restoring chart from backup due to invalid data...');
            userTicketsChart.data.labels = [...chartDataBackup.labels];
            userTicketsChart.data.datasets[0].data = [...chartDataBackup.data];
            userTicketsChart.update('active');
        } else {
            // Only clear if no backup available
            userTicketsChart.data.labels = [];
            userTicketsChart.data.datasets[0].data = [];
            userTicketsChart.update('active');
        }
        
        // Hide loading overlay even if no data
        hideChartLoading();
    }
}

function updateDailyClosuresData() {
    // Check cache first
    const now = Date.now();
    const period = currentPeriod || getCurrentPeriod() || 'today';
    
    // Use cached data if available and not expired (reduced cache duration to prevent stale data)
    if (ticketDataCache.data && 
        ticketDataCache.data.period === period && 
        (now - ticketDataCache.lastUpdate) < 30000) { // 30 seconds instead of longer cache
        console.log('üìä Using cached ticket closure data');
        updateChartWithData(ticketDataCache.data);
        return;
    }
    
    // Show loading overlay if we don't have cached data
    if (!ticketDataCache.data || ticketDataCache.data.period !== period) {
        showChartLoading();
    }
    
    // Fetch real data from API
    const endpoint = period === 'today' ? 
        '/api/tickets/closures/today' : 
        `/api/tickets/closures/period?period=${period}`;
    
    console.log('üîÑ Fetching ticket closure data from:', endpoint);
    console.log('üìä Current period:', period);
    
    fetch(endpoint)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('üîÑ Raw API response:', data);
            
            if (data.success) {
                console.log('‚úÖ Received real ticket closure data:', data);
                
                // Cache the data
                ticketDataCache.data = {
                    ...data,
                    period: period
                };
                ticketDataCache.lastUpdate = Date.now();
                
                // Also cache to localStorage for instant loading on next page load
                localStorage.setItem('yam_ticket_closures_cache', JSON.stringify({
                    data: data,
                    timestamp: Date.now()
                }));
                
                // Store sync status
                if (data.sync_status) {
                    syncStatus = data.sync_status;
                    updateSyncStatusDisplay();
                }
                
                // Update chart with real data
                updateChartWithData(data);
                
                // Update top performers list with real data
                console.log('Updating top performers...');
                updateTopPerformers(data);
                
                // Update stats display
                console.log('Updating stats display...');
                updateDailyClosuresStatsFromData(data);
                
                // Show success message if data was just synced
                if (data.sync_status && data.sync_status.sync_count_today > 0) {
                    showToast(`‚úÖ Data updated! ${data.total_closed} tickets processed`, 'success');
                }
            } else {
                console.error('‚ùå API returned error:', data.error);
                console.log('‚ö†Ô∏è API error - clearing chart data');
                // Clear chart data instead of loading fallback
                if (userTicketsChart) {
                    userTicketsChart.data.labels = [];
                    userTicketsChart.data.datasets[0].data = [];
                    userTicketsChart.update('none');
                }
            }
        })
        .catch(error => {
            console.error('‚ùå Error fetching ticket closure data:', error);
            console.log('‚ö†Ô∏è Falling back to empty data instead of dummy data');
            // Don't load fallback data - show empty chart instead
            if (userTicketsChart) {
                userTicketsChart.data.labels = [];
                userTicketsChart.data.datasets[0].data = [];
                userTicketsChart.update('none');
                console.log('üìä Chart cleared due to API error');
            }
        });
}

function loadFallbackData() {
    console.warn('Loading fallback dummy data due to API error');
    
    // Generate fallback data
    const fallbackData = generateDailyClosuresDataForPeriod(currentPeriod || getCurrentPeriod() || 'today');
    
    if (userTicketsChart) {
        userTicketsChart.data.labels = fallbackData.labels;
        userTicketsChart.data.datasets[0].data = fallbackData.periodData;
        userTicketsChart.update('none');
    }
    
    updateTopPerformers(fallbackData);
    updateDailyClosuresStatsForPeriod(currentPeriod || getCurrentPeriod() || 'today');
}

function updateDailyClosuresStatsFromData(data, period = 'today') {
    const totalClosed = data.total_closed || 0;
    const topPerformer = data.top_performer;
    
    // Update total tickets display - Fixed element ID
    const totalElement = document.getElementById('ticketsClosedToday');
    if (totalElement) {
        totalElement.textContent = totalClosed;
    }
    
    // Update top performer display
    const topCloserElement = document.getElementById('topCloserToday');
    if (topCloserElement && topPerformer) {
        topCloserElement.textContent = `${topPerformer.username} (${topPerformer.tickets_closed})`;
    }
    
    // Update the total-tickets span to match the ticketsClosedToday element
    const totalTicketsSpans = document.querySelectorAll('.total-tickets');
    totalTicketsSpans.forEach(span => {
        span.textContent = `Total: ${totalClosed} tickets`;
    });
    
    // Update sync status if available
    if (data.sync_status) {
        updateSyncStatusDisplay(data.sync_status);
    }
    
    console.log(`üìä Updated stats for period ${period}: Total=${totalClosed}, Top=${topPerformer?.username || 'None'}`);
}

function clearDailyClosuresStats() {
    const totalElement = document.getElementById('ticketsClosedToday');
    const topCloserElement = document.getElementById('topCloserToday');
    
    if (totalElement) {
        totalElement.textContent = '-';
    }
    
    if (topCloserElement) {
        topCloserElement.textContent = '-';
    }
    
    // Clear the total-tickets span as well
    const totalTicketsSpans = document.querySelectorAll('.total-tickets');
    totalTicketsSpans.forEach(span => {
        span.textContent = 'Total: 0 tickets';
    });
}

function updateSyncStatusDisplay(status = syncStatus) {
    if (!status) return;
    
    const syncStatusElement = document.getElementById('syncStatus');
    if (!syncStatusElement) return;
    
    const canSync = status.can_sync_now;
    const minutesUntilNext = status.minutes_until_next || 0;
    const lastSyncTime = status.last_sync_time;
    const ticketsProcessed = status.tickets_processed_today || 0;
    
    let statusText = '';
    let statusClass = '';
    
    if (canSync) {
        statusText = 'üîÑ Ready to sync';
        statusClass = 'text-success';
    } else {
        statusText = `‚è∞ Next sync in ${minutesUntilNext} minutes`;
        statusClass = 'text-warning';
    }
    
    if (lastSyncTime) {
        const lastSync = new Date(lastSyncTime);
        const timeAgo = Math.floor((Date.now() - lastSync.getTime()) / 60000); // minutes ago
        statusText += ` | Last: ${timeAgo}m ago (${ticketsProcessed} tickets)`;
    }
    
    syncStatusElement.textContent = statusText;
    syncStatusElement.className = `sync-status ${statusClass}`;
}

function checkSyncStatus() {
    fetch('/api/tickets/sync-status')
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                syncStatus = data.sync_info;
                updateSyncStatusDisplay();
            }
        })
        .catch(error => {
            console.error('Error checking sync status:', error);
        });
}

function checkForCacheInvalidation() {
    // Check if we should invalidate cache based on leaderboard sync timing
    const now = new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();
    
    // Leaderboard sync runs every hour, so check if we're near the sync time
    // and if our cache is older than the expected sync interval
    const cachedData = localStorage.getItem('yam_ticket_closures_cache');
    if (cachedData) {
        try {
            const parsed = JSON.parse(cachedData);
            const cacheAge = Date.now() - parsed.timestamp;
            
            // If cache is older than 5 minutes and we're near the top of the hour,
            // invalidate it to ensure fresh data
            if (cacheAge > 300000 && currentMinute < 5) { // Cache > 5 min old and within first 5 minutes of hour
                console.log('üîÑ Cache is stale and near sync time, invalidating...');
                invalidateTicketCache();
                updateDailyClosuresData(); // Force fresh data fetch
            }
        } catch (e) {
            console.log('‚ö†Ô∏è Error checking cache age:', e);
        }
    }
    
    // Check if leaderboard sync is likely running (around the top of the hour)
    if (currentMinute >= 0 && currentMinute <= 2) {
        // Show sync indicator
        showSyncIndicator();
    } else {
        // Hide sync indicator
        hideSyncIndicator();
    }
}

function showSyncIndicator() {
    const chartContainer = document.querySelector('.user-tickets-chart.enhanced');
    if (chartContainer) {
        let indicator = chartContainer.querySelector('.sync-indicator');
        if (!indicator) {
            indicator = document.createElement('div');
            indicator.className = 'sync-indicator';
            indicator.innerHTML = `
                <div style="position: absolute; top: 10px; right: 10px; background: rgba(139, 92, 246, 0.9); color: white; padding: 8px 12px; border-radius: 6px; font-size: 12px; z-index: 1000;">
                    üîÑ Syncing data...
                </div>
            `;
            chartContainer.style.position = 'relative';
            chartContainer.appendChild(indicator);
        }
        indicator.style.display = 'block';
    }
}

function hideSyncIndicator() {
    const chartContainer = document.querySelector('.user-tickets-chart.enhanced');
    if (chartContainer) {
        const indicator = chartContainer.querySelector('.sync-indicator');
        if (indicator) {
            indicator.style.display = 'none';
        }
    }
}

function updateTopPerformers(data) {
    // Update both the hidden section and the modal content
    const topPerformersContainer = document.getElementById('topPerformers');
    const topPerformersModalContent = document.getElementById('topPerformersModalContent');
    
    // Use modal content if available, otherwise fall back to hidden section
    const container = topPerformersModalContent || topPerformersContainer;
    if (!container) return;
    
    let performers = [];
    
    if (data.users && Array.isArray(data.users)) {
        // Real data from API
        performers = data.users
            .sort((a, b) => b.tickets_closed - a.tickets_closed)
            .slice(0, 5);
    } else if (data.labels && data.data) {
        // Chart data format
        performers = data.labels.map((label, index) => ({
            username: label,
            tickets_closed: data.data[index] || 0,
            role: 'User'
        })).sort((a, b) => b.tickets_closed - a.tickets_closed).slice(0, 5);
    }
    
    // Clear existing content
    container.innerHTML = '';
    
    if (performers.length === 0) {
        container.innerHTML = '<div class="no-data">No data available</div>';
        return;
    }
    
    // Create a list for the performers
    const performersList = document.createElement('ul');
    performersList.className = 'performers-list';
    performersList.style.cssText = 'list-style: none; padding: 0; margin: 0;';
    
    // Add performers to list
    performers.forEach((performer, index) => {
        const listItem = document.createElement('li');
        listItem.className = 'performer-item';
        listItem.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0; border-bottom: 1px solid rgba(255, 255, 255, 0.1);';
        
        const rank = index + 1;
        const rankIcon = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `${rank}.`;
        
        listItem.innerHTML = `
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <div class="performer-avatar" style="width: 32px; height: 32px; border-radius: 50%; overflow: hidden; background: linear-gradient(135deg, #8B5CF6, #A855F7); display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 0.8rem; border: 2px solid rgba(139, 92, 246, 0.3);">
                    ${getUserProfileImage(performer, performer.username)}
                </div>
                <span class="performer-name" style="color: #ffffff; font-weight: 500;">
                    <span class="rank-icon" style="margin-right: 0.5rem;">${rankIcon}</span>
                    ${performer.username}
                    <small style="color: rgba(255, 255, 255, 0.6); margin-left: 0.5rem;">(${performer.role})</small>
                </span>
            </div>
            <span class="ticket-count" style="background: #8B5CF6; color: white; padding: 0.25rem 0.5rem; border-radius: 4px; font-weight: 600;">${performer.tickets_closed}</span>
        `;
        
        performersList.appendChild(listItem);
    });
    
    container.appendChild(performersList);
}

function updateDailyClosuresStats() {
    fetch('/api/tickets/stats')
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const totalElement = document.getElementById('ticketsClosedToday');
                const topCloserElement = document.getElementById('topCloserToday');
                
                if (totalElement) {
                    totalElement.textContent = data.today_total || 0;
                }
                
                if (topCloserElement && data.top_performer) {
                    topCloserElement.textContent = `${data.top_performer.username} (${data.top_performer.tickets_closed})`;
                }
            }
        })
        .catch(error => {
            console.error('Error fetching ticket stats:', error);
        });
}

function getCurrentPeriod() {
    // First try to get from global variable (most reliable)
    if (currentPeriod) {
        return currentPeriod;
    }
    
    // Fallback: look for active time button
    const periodButtons = document.querySelectorAll('.user-tickets-card .time-btn');
    for (const button of periodButtons) {
        if (button.classList.contains('active')) {
            return button.getAttribute('data-period');
        }
    }
    return 'today';
}

function filterDailyClosures(period) {
    console.log(`üîÑ Filtering daily closures for period: ${period}`);
    
    // Update global period tracking
    currentPeriod = period;
    console.log(`üìÖ Global period updated to: ${currentPeriod}`);
    
    // Update the chart dataset label
    const periodLabel = period === 'today' ? 'Closed Today' :
                       period === 'yesterday' ? 'Closed Yesterday' :
                       period === 'week' ? 'Closed This Week' : 'Closed This Month';
    
    if (userTicketsChart) {
        userTicketsChart.data.datasets[0].label = periodLabel;
    }
    
    // Update the stats label dynamically
    const statsLabel = document.getElementById('ticketsClosedLabel');
    if (statsLabel) {
        statsLabel.textContent = periodLabel;
    }
    
    // Update time control buttons
    document.querySelectorAll('.user-tickets-card .time-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.getAttribute('data-period') === period) {
            btn.classList.add('active');
        }
    });
    
    // Clear cache to force fresh data fetch
    ticketDataCache.data = null;
    ticketDataCache.lastUpdate = 0;
    
    // Show loading overlay
    showChartLoading();
    
    // Fetch new data for the selected period using the enhanced API
    const endpoint = `/api/tickets/closures/period?period=${period}`;
    
    console.log(`üìä Fetching data from: ${endpoint}`);
    
    fetch(endpoint)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
        })
        .then(data => {
            console.log(`üîÑ Received data for period ${period}:`, data);
            
            if (data.success) {
                // Cache the data
                ticketDataCache.data = {
                    ...data,
                    period: period
                };
                ticketDataCache.lastUpdate = Date.now();
                
                // Update chart with new data
                updateChartWithData(data);
                
                // Update top performers
                updateTopPerformers(data);
                
                // Update stats display with proper period context
                updateDailyClosuresStatsFromData(data, period);
                
                console.log(`‚úÖ Successfully updated chart for period ${period}`);
            } else {
                console.error(`‚ùå API returned error for period ${period}:`, data.error);
                // Show empty chart
                if (userTicketsChart) {
                    userTicketsChart.data.labels = [];
                    userTicketsChart.data.datasets[0].data = [];
                    userTicketsChart.update('none');
                }
                // Clear stats
                clearDailyClosuresStats();
            }
        })
        .catch(error => {
            console.error(`‚ùå Error fetching data for period ${period}:`, error);
            // Show empty chart
            if (userTicketsChart) {
                userTicketsChart.data.labels = [];
                userTicketsChart.data.datasets[0].data = [];
                userTicketsChart.update('none');
            }
            // Clear stats
            clearDailyClosuresStats();
        })
        .finally(() => {
            // Hide loading overlay
            hideChartLoading();
        });
}

function generateDailyClosuresDataForPeriod(period) {
    // Only use real users, no dummy data
    const users = realUsers.length > 0 ? realUsers : [];
    
    // If no real users, return empty data
    if (users.length === 0) {
        return { labels: [], periodData: [] };
    }
    
    const labels = users.slice(0, 8).map(user => user.username);
    
    let periodData;
    switch (period) {
        case 'today':
            periodData = users.slice(0, 8).map(() => Math.floor(Math.random() * 15) + 2);
            break;
        case 'week':
            periodData = users.slice(0, 8).map(() => Math.floor(Math.random() * 80) + 20);
            break;
        case 'month':
            periodData = users.slice(0, 8).map(() => Math.floor(Math.random() * 300) + 150);
            break;
        default:
            periodData = users.slice(0, 8).map(() => Math.floor(Math.random() * 15) + 2);
    }
    
    return { labels, periodData };
}

function updateTopPerformers(data) {
    const topPerformersElement = document.getElementById('topPerformers');
    const topPerformersModalElement = document.getElementById('topPerformersModalContent');
    
    if (!topPerformersElement && !topPerformersModalElement) {
        return;
    }
    
    const users = data.users || [];
    // Get the total from the ticketsClosedToday element to ensure consistency
    const ticketsClosedElement = document.getElementById('ticketsClosedToday');
    const totalClosed = ticketsClosedElement ? parseInt(ticketsClosedElement.textContent) || 0 : (data.total_closed || 0);
    
    if (users.length === 0) {
        const noDataHtml = '<div class="no-data">No ticket closure data available</div>';
        if (topPerformersElement) topPerformersElement.innerHTML = noDataHtml;
        if (topPerformersModalElement) topPerformersModalElement.innerHTML = noDataHtml;
        return;
    }
    
    // Sort users by tickets closed (descending)
    const sortedUsers = users.sort((a, b) => b.tickets_closed - a.tickets_closed);
    
    let performersHtml = `
        <div class="performers-header">
            <h4>Top Performers Today</h4>
            <span class="total-tickets">Total: ${totalClosed} tickets</span>
        </div>
        <div class="performers-list">
    `;
    
    sortedUsers.forEach((user, index) => {
        const rank = index + 1;
        const rankClass = rank === 1 ? 'gold' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : '';
        const rankIcon = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `#${rank}`;
        
        performersHtml += `
            <div class="performer-item ${rankClass}">
                <div class="performer-rank">${rankIcon}</div>
                <div class="performer-avatar">
                    ${getUserProfileImage(user, user.username)}
                </div>
                <div class="performer-info">
                    <div class="performer-name">${user.username}</div>
                    <div class="performer-role">${user.role || 'User'}</div>
                </div>
                <div class="performer-stats">
                    <div class="tickets-count">${user.tickets_closed}</div>
                    <div class="tickets-label">tickets</div>
                </div>
            </div>
        `;
    });
    
    performersHtml += '</div>';
    
    if (topPerformersElement) topPerformersElement.innerHTML = performersHtml;
    if (topPerformersModalElement) topPerformersModalElement.innerHTML = performersHtml;
}

function updateDailyClosuresStatsForPeriod(period) {
    const data = generateDailyClosuresDataForPeriod(period);
    const total = data.periodData.reduce((sum, count) => sum + count, 0);
    const topCloserToday = data.labels[0] || 'N/A';
    
    const totalElement = document.getElementById('ticketsClosedToday');
    const topCloserElement = document.getElementById('topCloserToday');
    
    if (totalElement) {
        totalElement.textContent = total;
    }
    
    if (topCloserElement) {
        topCloserElement.textContent = topCloserToday;
    }
    
    // Update the total-tickets span to match the ticketsClosedToday element
    const totalTicketsSpans = document.querySelectorAll('.total-tickets');
    totalTicketsSpans.forEach(span => {
        span.textContent = `Total: ${total} tickets`;
    });
}

// Manual sync function for admin use
function manualSync() {
    if (!confirm('This will manually sync ticket data from Freshworks. Continue?')) {
        return;
    }
    
    fetch('/api/tickets/sync', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            date: new Date().toISOString().split('T')[0],
            force: false
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showToast(`‚úÖ ${data.message}`, 'success');
            // Refresh data after sync
            setTimeout(() => {
                updateDailyClosuresData();
                updateDailyClosuresStats();
            }, 2000);
        } else {
            showToast(`‚ùå ${data.error}`, 'error');
        }
    })
    .catch(error => {
        console.error('Error during manual sync:', error);
        showToast('‚ùå Sync failed. Check console for details.', 'error');
    });
}

// Force sync function for admin use (bypasses rate limiting)
function forceSync() {
    if (!confirm('This will force sync ticket data, bypassing rate limits. Continue?')) {
        return;
    }
    
    fetch('/api/tickets/force-sync', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            date: new Date().toISOString().split('T')[0]
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showToast(`‚úÖ ${data.message}`, 'success');
            // Refresh data after sync
            setTimeout(() => {
                updateDailyClosuresData();
                updateDailyClosuresStats();
            }, 2000);
        } else {
            showToast(`‚ùå ${data.error}`, 'error');
        }
    })
    .catch(error => {
        console.error('Error during force sync:', error);
        showToast('‚ùå Force sync failed. Check console for details.', 'error');
    });
}

// Admin modal functions
function openAdminSyncModal() {
    const modal = document.getElementById('adminSyncModal');
    if (modal) {
        modal.classList.add('show');
        loadAdminStats();
    }
}

function closeAdminSyncModal() {
    const modal = document.getElementById('adminSyncModal');
    if (modal) {
        modal.classList.remove('show');
    }
}

function loadAdminStats() {
    const loadingElement = document.getElementById('adminStatsLoading');
    const contentElement = document.getElementById('adminStatsContent');
    
    if (loadingElement) loadingElement.style.display = 'flex';
    if (contentElement) contentElement.style.display = 'none';
    
    fetch('/api/tickets/admin-stats')
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                updateAdminStatsDisplay(data);
                if (loadingElement) loadingElement.style.display = 'none';
                if (contentElement) contentElement.style.display = 'block';
            } else {
                throw new Error(data.error || 'Failed to load admin stats');
            }
        })
        .catch(error => {
            console.error('Error loading admin stats:', error);
            if (loadingElement) {
                loadingElement.innerHTML = `
                    <div class="error-state">
                        <i class="bi bi-exclamation-triangle-fill"></i>
                        <h4>Error Loading Stats</h4>
                        <p>${error.message}</p>
                        <button class="btn btn-primary" onclick="closeAdminSyncModal()">Close</button>
                    </div>
                `;
            }
        });
}

function updateAdminStatsDisplay(data) {
    // Update database information
    if (data.last_sync_time) {
        document.getElementById('lastSyncTime').textContent = new Date(data.last_sync_time).toLocaleString();
    }
    if (data.total_closure_records !== undefined) {
        document.getElementById('totalClosureRecords').textContent = data.total_closure_records;
    }
    if (data.mapped_users_count !== undefined) {
        document.getElementById('mappedUsersCount').textContent = data.mapped_users_count;
    }
    if (data.days_with_data !== undefined) {
        document.getElementById('daysWithData').textContent = data.days_with_data;
    }
    
    // Update sync status
    if (data.next_sync_time) {
        document.getElementById('nextSyncTime').textContent = new Date(data.next_sync_time).toLocaleString();
    }
    if (data.sync_count_today !== undefined) {
        document.getElementById('syncCountToday').textContent = data.sync_count_today;
    }
    if (data.tickets_processed_today !== undefined) {
        document.getElementById('ticketsProcessedToday').textContent = data.tickets_processed_today;
    }
    if (data.total_syncs !== undefined) {
        document.getElementById('totalSyncs').textContent = data.total_syncs;
    }
    
    // Update recent activity
    if (data.recent_activity) {
        const activityElement = document.getElementById('recentActivity');
        if (activityElement) {
            let activityHtml = '';
            data.recent_activity.forEach(activity => {
                activityHtml += `
                    <div class="activity-item">
                        <div class="activity-text">${activity.description}</div>
                        <div class="activity-time">${new Date(activity.timestamp).toLocaleString()}</div>
                    </div>
                `;
            });
            activityElement.innerHTML = activityHtml;
        }
    }
}

function refreshUserMappings() {
    if (!confirm('This will refresh user mappings from the IDs.txt file. Continue?')) {
        return;
    }
    
    fetch('/api/tickets/sync-from-ids', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showToast(`‚úÖ ${data.message}`, 'success');
            // Refresh admin stats
            setTimeout(() => {
                loadAdminStats();
            }, 1000);
        } else {
            showToast(`‚ùå ${data.error}`, 'error');
        }
    })
    .catch(error => {
        console.error('Error refreshing user mappings:', error);
        showToast('‚ùå Failed to refresh user mappings', 'error');
    });
}

function exportAdminData() {
    showToast('Export feature coming soon!', 'info');
}

// ENHANCED MODAL FUNCTIONS: Chart stability-aware modal operations
function openDailyPerformanceModal() {
    const modal = document.getElementById('dailyPerformanceModal');
    if (modal) {
        // ENHANCED STABILITY: Backup chart data before modal operations
        backupChartData();
        
        modal.classList.add('show');
        
        // ENHANCED STABILITY: Use safe data refresh that doesn't interfere with chart
        safeRefreshModalData();
    }
}

function safeRefreshModalData() {
    // First try to get data from the chart without modifying it
    let currentData = {
        labels: userTicketsChart ? [...userTicketsChart.data.labels] : [],
        data: userTicketsChart ? [...userTicketsChart.data.datasets[0].data] : [],
        users: []
    };
    
    // If chart has valid data, use it for modal
    if (currentData.labels.length > 0 && currentData.data.length > 0) {
        console.log('üìä Using existing chart data for modal');
        currentData.users = currentData.labels.map((label, index) => ({
            username: label,
            tickets_closed: currentData.data[index] || 0,
            role: 'User'
        }));
        
        updateTopPerformers(currentData);
        
        // ENHANCED STABILITY: Verify chart is still stable after modal update
        setTimeout(() => {
            verifyChartStability();
        }, 100);
    } else {
        // Only fetch fresh data if chart is empty
        console.log('üìä Chart has no data, fetching fresh data for modal...');
        fetch('/api/tickets/closures/today')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    updateTopPerformers(data);
                    
                    // ENHANCED STABILITY: Update chart with fresh data if it was empty
                    if (userTicketsChart && (!userTicketsChart.data.labels || userTicketsChart.data.labels.length === 0)) {
                        console.log('üìä Updating chart with fresh data from modal fetch');
                        updateChartWithData(data);
                    }
                } else {
                    console.error('‚ùå Failed to fetch data for modal:', data.error);
                }
            })
            .catch(error => {
                console.error('‚ùå Error fetching data for modal:', error);
            });
    }
}

function verifyChartStability() {
    if (!userTicketsChart) return;
    
    const currentLabels = userTicketsChart.data.labels || [];
    const currentData = userTicketsChart.data.datasets[0]?.data || [];
    
    const hasValidData = currentLabels.length > 0 && currentData.length > 0 && 
                        currentData.some(value => value > 0);
    
    if (!hasValidData) {
        console.warn('‚ö†Ô∏è Chart data lost after modal operation, attempting recovery...');
        triggerChartRecovery();
    } else {
        console.log('‚úÖ Chart stability verified after modal operation');
    }
}

function closeDailyPerformanceModal() {
    const modal = document.getElementById('dailyPerformanceModal');
    if (modal) {
        modal.classList.remove('show');
        
        // ENHANCED STABILITY: Verify chart stability after modal closes
        setTimeout(() => {
            verifyChartStability();
        }, 300);
    }
}

// Placeholder functions for ticket actions
function createQuickTicket() {
    showToast('Quick ticket creation feature coming soon!', 'info');
}

function viewDailyReport() {
    showToast('Daily report feature coming soon!', 'info');
}

function exportClosureData() {
    showToast('Export feature coming soon!', 'info');
}

function openDailyAnalytics() {
    showToast('Daily analytics feature coming soon!', 'info');
}

// Helper function to show toast messages
function showToast(message, type = 'info') {
    // Check if toast function exists
    if (typeof window.showToast === 'function') {
        window.showToast(message, type);
    } else {
        // Fallback to console
        console.log(`[${type.toUpperCase()}] ${message}`);
    }
}

// Debug function to test API endpoint
function testTicketClosuresAPI() {
    console.log('üß™ Testing ticket closures API...');
    fetch('/api/tickets/closures/today')
        .then(response => {
            console.log('üì° API Response status:', response.status);
            return response.json();
        })
        .then(data => {
            console.log('üìä API Response data:', data);
            if (data.success) {
                console.log('‚úÖ API returned success');
                console.log('üìà Labels:', data.labels);
                console.log('üìä Data:', data.data);
                console.log('üë• Users:', data.users);
                console.log('üìã Total closed:', data.total_closed);
                
                // If we have data, test updating the chart
                if (data.labels && data.data && data.labels.length > 0) {
                    console.log('üß™ Testing chart update with real data...');
                    if (userTicketsChart) {
                        userTicketsChart.data.labels = data.labels;
                        userTicketsChart.data.datasets[0].data = data.data;
                        userTicketsChart.update('none'); // Use 'none' to prevent zoom changes
                        console.log('‚úÖ Chart updated with test data');
                    } else {
                        console.error('‚ùå Chart not initialized yet');
                    }
                }
            } else {
                console.error('‚ùå API returned error:', data.error);
                // Test with dummy data if API fails
                testChartWithDummyData();
            }
        })
        .catch(error => {
            console.error('‚ùå API request failed:', error);
            // Test with dummy data if API fails
            testChartWithDummyData();
        });
}

// Test chart with dummy data
function testChartWithDummyData() {
    console.log('üß™ Testing chart with dummy data...');
    if (userTicketsChart) {
        const dummyLabels = ['User 1', 'User 2', 'User 3', 'User 4', 'User 5'];
        const dummyData = [5, 3, 7, 2, 4];
        
        userTicketsChart.data.labels = dummyLabels;
        userTicketsChart.data.datasets[0].data = dummyData;
        userTicketsChart.update('none'); // Use 'none' to prevent zoom changes
        console.log('‚úÖ Chart updated with dummy data');
    } else {
        console.error('‚ùå Chart not initialized yet');
    }
}

// Cache management functions
function clearTicketCache() {
    localStorage.removeItem('yam_ticket_closures_cache');
    ticketDataCache.data = null;
    ticketDataCache.lastUpdate = 0;
    console.log('üóëÔ∏è Ticket cache cleared');
}

// ENHANCED MANUAL REFRESH: Robust chart refresh with stability checks
function refreshTicketData() {
    console.log('üîÑ Manually refreshing ticket data...');
    
    // ENHANCED STABILITY: Backup current chart data before refresh
    backupChartData();
    
    clearTicketCache();
    showChartLoading();
    
    // ENHANCED STABILITY: Use enhanced data update
    updateDailyClosuresData();
    

    
    // ENHANCED STABILITY: Verify chart stability after manual refresh
    setTimeout(() => {
        verifyChartStability();
    }, 1000);
}

// ENHANCED STABILITY: Manual chart recovery function for users
function forceChartRecovery() {
    console.log('üîÑ Manual chart recovery triggered by user...');
    
    if (!userTicketsChart) {
        console.error('‚ùå Chart not initialized, cannot recover');
        return;
    }
    
    // Reset recovery counters
    chartStabilityMonitor.recoveryAttempts = 0;
    chartStabilityMonitor.consecutiveFailures = 0;
    
    // Force immediate recovery
    attemptChartRecovery();
    
    // Show user feedback
    if (typeof showToast === 'function') {
        showToast('üîÑ Chart recovery in progress...', 'info');
    }
}

// ENHANCED STABILITY: Quick chart health check function
function checkChartHealth() {
    if (!userTicketsChart) {
        console.log('üìä Chart not initialized');
        return false;
    }
    
    const currentLabels = userTicketsChart.data.labels || [];
    const currentData = userTicketsChart.data.datasets[0]?.data || [];
    
    const hasValidData = currentLabels.length > 0 && currentData.length > 0 && 
                        currentData.some(value => value > 0);
    
    console.log('üìä Chart health check:', {
        hasChart: !!userTicketsChart,
        labelsCount: currentLabels.length,
        dataCount: currentData.length,
        hasValidData: hasValidData,
        backupAvailable: chartDataBackup.labels.length > 0
    });
    
    return hasValidData;
}

// ENHANCED PAGE LOAD: Chart stability monitoring and recovery
document.addEventListener('DOMContentLoaded', function() {
    // Test API after a short delay
    setTimeout(testTicketClosuresAPI, 2000);
    
    // ENHANCED STABILITY: Ensure chart stability after page is fully loaded
    setTimeout(() => {
        if (userTicketsChart) {
            console.log('üîÑ Ensuring chart stability...');
            try {
                // Only update data, don't resize to prevent zoom changes
                userTicketsChart.update('none');
                
                // ENHANCED STABILITY: Verify chart is stable after update
                setTimeout(() => {
                    verifyChartStability();
                }, 100);
            } catch (error) {
                console.warn('‚ö†Ô∏è Chart stability check failed:', error);
                triggerChartRecovery();
            }
        }
    }, 3000);
    
    // ENHANCED STABILITY: Add global event listeners for chart stability
    setupGlobalChartStabilityListeners();
});

function setupGlobalChartStabilityListeners() {
    // Monitor for visibility changes that might affect chart rendering
    document.addEventListener('visibilitychange', function() {
        if (!document.hidden && userTicketsChart) {
            console.log('üìä Page became visible, checking chart stability...');
            setTimeout(() => {
                verifyChartStability();
            }, 500);
        }
    });
    
    // Monitor for window resize events
    window.addEventListener('resize', function() {
        if (userTicketsChart) {
            console.log('üìä Window resized, ensuring chart stability...');
            setTimeout(() => {
                verifyChartStability();
            }, 200);
        }
    });
    
    // Monitor for focus events (when user returns to tab)
    window.addEventListener('focus', function() {
        if (userTicketsChart) {
            console.log('üìä Window focused, checking chart stability...');
            setTimeout(() => {
                verifyChartStability();
            }, 300);
        }
    });
}

// ENHANCED USER TICKET DETAILS MODAL FUNCTIONS: Chart stability-aware
function showUserTicketDetails(username, ticketCount) {
    console.log(`üîç Loading ticket details for ${username} (${ticketCount} tickets)`);
    
    // ENHANCED STABILITY: Backup chart data before opening user details modal
    backupChartData();
    
    // CRITICAL: Hide all non-modal elements and disable page scrollbar
    if (typeof window.hideAllNonModalElements === 'function') {
        window.hideAllNonModalElements();
    }
    
    // Show loading state
    const modal = document.getElementById('userTicketDetailsModal');
    if (modal) {
        modal.classList.add('show');
        document.getElementById('userTicketDetailsContent').innerHTML = `
            <div class="loading-state">
                <div class="loading-spinner"></div>
                <p>Loading ticket details for ${username}...</p>
            </div>
        `;
        console.log('‚úÖ Modal opened and loading state set');
    } else {
        console.error('‚ùå Modal element not found!');
        return;
    }
    
    // Get current period for the API call - use global variable for accuracy
    const period = currentPeriod || getCurrentPeriod() || 'today';
    console.log(`üìÖ Current period: ${period} (from global: ${currentPeriod})`);
    
    // Calculate target date based on period
    let targetDate;
    const today = new Date();
    
    if (period === 'today') {
        targetDate = today.toISOString().split('T')[0];
    } else if (period === 'yesterday') {
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);
        targetDate = yesterday.toISOString().split('T')[0];
    } else if (period === 'week') {
        // For week view, show today's data but indicate it's aggregated
        targetDate = today.toISOString().split('T')[0];
    } else if (period === 'month') {
        // For month view, show today's data but indicate it's aggregated
        targetDate = today.toISOString().split('T')[0];
    } else {
        targetDate = today.toISOString().split('T')[0];
    }
    
    console.log(`üìÖ Target date: ${targetDate} for period: ${period}`);
    
    // Fetch ticket details from API with period context
    const apiUrl = `/api/tickets/user-details/${encodeURIComponent(username)}?date=${targetDate}&period=${period}`;
    console.log(`üåê Fetching from: ${apiUrl}`);
    console.log(`üìä API call details: username=${username}, date=${targetDate}, period=${period}`);
    
    fetch(apiUrl)
        .then(response => {
            console.log(`üì° API Response status: ${response.status}`);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
        })
        .then(data => {
            console.log(`üìä API Response data:`, data);
            if (data.success) {
                displayUserTicketDetails(data, username, ticketCount);
                
                // ENHANCED STABILITY: Verify chart stability after modal content is loaded
                setTimeout(() => {
                    verifyChartStability();
                }, 200);
            } else {
                throw new Error(data.error || 'Failed to load ticket details');
            }
        })
        .catch(error => {
            console.error('‚ùå Error loading ticket details:', error);
            document.getElementById('userTicketDetailsContent').innerHTML = `
                <div class="error-state">
                    <i class="bi bi-exclamation-triangle-fill"></i>
                    <h4>Error Loading Details</h4>
                    <p>${error.message}</p>
                    <button class="btn btn-primary" onclick="closeUserTicketDetailsModal()">Close</button>
                </div>
            `;
            
            // ENHANCED STABILITY: Verify chart stability even after error
            setTimeout(() => {
                verifyChartStability();
            }, 200);
        });
}

function displayUserTicketDetails(data, username, ticketCount) {
    console.log(`üìã Displaying ticket details for ${username}:`, data);
    
    const { user, tickets, total_tickets, summary, date, period, start_date, end_date } = data;
    
    console.log(`üìä Ticket data breakdown:`, {
        user,
        ticketsCount: tickets.length,
        total_tickets,
        summary,
        date,
        period,
        start_date,
        end_date
    });
    
    let ticketsHtml = '';
    
    if (tickets.length === 0) {
        const dateText = period && (period === 'week' || period === 'month') 
            ? `during the ${period} period (${new Date(start_date).toLocaleDateString()} - ${new Date(end_date).toLocaleDateString()})`
            : `on ${new Date(date).toLocaleDateString()}`;
            
        ticketsHtml = `
            <div class="no-tickets">
                <i class="bi bi-inbox"></i>
                <h4>No Tickets Found</h4>
                <p>No tickets were found for ${username} ${dateText}</p>
            </div>
        `;
        console.log(`üì≠ No tickets found for ${username} ${dateText}`);
    } else {
        console.log(`üé´ Found ${tickets.length} tickets for ${username}`);
        tickets.forEach((ticket, index) => {
            console.log(`üé´ Ticket ${index + 1}:`, ticket);
            const statusClass = getStatusClass(ticket.status);
            const priorityClass = getPriorityClass(ticket.priority);
            const urgencyClass = getUrgencyClass(ticket.urgency);
            
            ticketsHtml += `
                <div class="ticket-item">
                    <div class="ticket-header">
                        <div class="ticket-number">${ticket.ticket_number}</div>
                        <div class="ticket-badges">
                            <span class="badge ${statusClass}">${getStatusText(ticket.status)}</span>
                            <span class="badge ${priorityClass}">${getPriorityText(ticket.priority)}</span>
                            <span class="badge ${urgencyClass}">${getUrgencyText(ticket.urgency)}</span>
                        </div>
                    </div>
                    <div class="ticket-subject">${ticket.subject}</div>
                    <div class="ticket-meta">
                        <span class="meta-item">
                            <i class="bi bi-calendar"></i>
                            Created: ${formatDate(ticket.created_at)}
                        </span>
                        <span class="meta-item">
                            <i class="bi bi-clock"></i>
                            Updated: ${formatDate(ticket.updated_at)}
                        </span>
                        ${ticket.resolved_at ? `
                            <span class="meta-item">
                                <i class="bi bi-check-circle"></i>
                                Resolved: ${formatDate(ticket.resolved_at)}
                            </span>
                        ` : ''}
                    </div>
                    ${ticket.description ? `
                        <div class="ticket-description">
                            ${ticket.description.length > 200 ? 
                                ticket.description.substring(0, 200) + '...' : 
                                ticket.description}
                        </div>
                    ` : ''}
                    ${ticket.tags && ticket.tags.length > 0 ? `
                        <div class="ticket-tags">
                            ${ticket.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
        });
    }
    
    const dateText = period && (period === 'week' || period === 'month') 
        ? `${period.charAt(0).toUpperCase() + period.slice(1)} Period (${new Date(start_date).toLocaleDateString()} - ${new Date(end_date).toLocaleDateString()})`
        : new Date(date).toLocaleDateString();
        
    const summaryHtml = `
        <div class="user-summary">
            <div class="user-info">
                <div class="user-avatar">
                    ${getUserProfileImage(user, username)}
                </div>
                <div class="user-details">
                    <h3>${username}</h3>
                    <p class="user-role">${user.role || 'User'}</p>
                    <p class="user-date">${dateText}</p>
                </div>
            </div>
            <div class="summary-stats">
                <div class="stat-item">
                    <div class="stat-number">${total_tickets}</div>
                    <div class="stat-label">Total Tickets</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number">${summary.total_closed}</div>
                    <div class="stat-label">Closed</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number">${summary.total_open}</div>
                    <div class="stat-label">Open</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number">${summary.high_priority}</div>
                    <div class="stat-label">High Priority</div>
                </div>
            </div>
        </div>
    `;
    
    const finalHtml = summaryHtml + ticketsHtml;
    console.log(`üìù Final HTML length: ${finalHtml.length} characters`);
    
    document.getElementById('userTicketDetailsContent').innerHTML = finalHtml;
    console.log('‚úÖ Ticket details displayed successfully');
}

function closeUserTicketDetailsModal() {
    const modal = document.getElementById('userTicketDetailsModal');
    if (modal) {
        modal.classList.remove('show');
        
        // CRITICAL: Show all non-modal elements and re-enable page scrollbar
        if (typeof window.showAllNonModalElements === 'function') {
            window.showAllNonModalElements();
        }
        
        // ENHANCED STABILITY: Verify chart stability after modal closes
        setTimeout(() => {
            verifyChartStability();
        }, 300);
    }
}

// Helper functions for ticket display
function getStatusClass(status) {
    const statusMap = {
        1: 'status-open',
        2: 'status-pending',
        3: 'status-resolved',
        4: 'status-closed',
        5: 'status-cancelled'
    };
    return statusMap[status] || 'status-unknown';
}

function getStatusText(status) {
    const statusMap = {
        1: 'Open',
        2: 'Pending',
        3: 'Resolved',
        4: 'Closed',
        5: 'Cancelled'
    };
    return statusMap[status] || 'Unknown';
}

function getPriorityClass(priority) {
    const priorityMap = {
        1: 'priority-low',
        2: 'priority-medium',
        3: 'priority-high',
        4: 'priority-urgent'
    };
    return priorityMap[priority] || 'priority-unknown';
}

function getPriorityText(priority) {
    const priorityMap = {
        1: 'Low',
        2: 'Medium',
        3: 'High',
        4: 'Urgent'
    };
    return priorityMap[priority] || 'Unknown';
}

function getUrgencyClass(urgency) {
    const urgencyMap = {
        1: 'urgency-low',
        2: 'urgency-medium',
        3: 'urgency-high',
        4: 'urgency-urgent'
    };
    return urgencyMap[urgency] || 'urgency-unknown';
}

function getUrgencyText(urgency) {
    const urgencyMap = {
        1: 'Low',
        2: 'Medium',
        3: 'High',
        4: 'Urgent'
    };
    return urgencyMap[urgency] || 'Unknown';
}

function formatDate(dateString) {
    if (!dateString) return 'N/A';
    try {
        const date = new Date(dateString);
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    } catch (e) {
        return 'Invalid Date';
    }
}

// Helper function to get user profile image with proper fallback
function getUserProfileImage(user, username) {
    const userInitial = username.charAt(0).toUpperCase();
    
    // Check if user has a custom profile picture
    if (user.profile_picture && 
        user.profile_picture !== 'default.png' && 
        user.profile_picture !== 'none' && 
        user.profile_picture.trim() !== '') {
        
        // If it's a full URL, use it directly
        if (user.profile_picture.startsWith('http://') || user.profile_picture.startsWith('https://')) {
            return `<img src="${user.profile_picture}" alt="${username}" onerror="this.onerror=null;this.style.display='none';this.nextElementSibling.style.display='flex';" />
                    <span style="display: none;">${userInitial}</span>`;
        }
        
        // If it's a relative path, construct the full path
        const imagePath = user.profile_picture.startsWith('/') ? 
            user.profile_picture : 
            `/static/uploads/profile_pictures/${user.profile_picture}`;
        
        return `<img src="${imagePath}" alt="${username}" onerror="this.onerror=null;this.style.display='none';this.nextElementSibling.style.display='flex';" />
                <span style="display: none;">${userInitial}</span>`;
    }
    
    // Fallback to default profile image
    return `<img src="/static/images/avatars/default.png" alt="${username}" onerror="this.onerror=null;this.style.display='none';this.nextElementSibling.style.display='flex';" />
            <span style="display: none;">${userInitial}</span>`;
}

// PERSISTENT TIMER COUNTDOWN FUNCTIONS
function startPersistentTimerCountdown() {
    console.log('üïê Starting persistent timer countdown display...');
    
    // Update countdown every 30 seconds
    setInterval(updatePersistentTimerCountdown, 30000);
    
    // Initial update
    updatePersistentTimerCountdown();
}

function updatePersistentTimerCountdown() {
    fetch('/api/timer/status')
    .then(response => response.json())
    .then(data => {
        if (data.success && data.data) {
            const status = data.data;
            const timeLeft = status.time_until_next;
            
            if (timeLeft.total_seconds > 0) {
                // Log countdown to console every 5 minutes
                if (timeLeft.total_seconds % 300 === 0) {
                    console.log(`üïê Next leaderboard sync in: ${timeLeft.formatted} (${timeLeft.hours}h ${timeLeft.minutes}m ${timeLeft.seconds}s)`);
                }
                
                // Log when getting close to sync time
                if (timeLeft.total_seconds <= 300) { // 5 minutes or less
                    console.log(`‚ö†Ô∏è Leaderboard sync in ${timeLeft.minutes}m ${timeLeft.seconds}s`);
                }
            } else {
                console.log('üîÑ Leaderboard sync due now');
            }
        }
    })
    .catch(error => {
        console.error('‚ùå Error getting timer status:', error);
    });
}


</script> 