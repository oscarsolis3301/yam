<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jarvis Chat</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js"></script>
</head>

<body data-username="{{ current_user.username|title if current_user.is_authenticated else '' }}">
<!-- AI BOT CHAT WIDGET -->
<button id="chat-toggle" class="btn btn-primary rounded-circle shadow" style="
position: fixed;
bottom: 1.5rem;
right: 1.5rem;
width: 56px;
height: 56px;
z-index: 1050;
display: flex;
align-items: center;
justify-content: center;
background-color: #0d6efd !important;
">
<i class="bi bi-chat-dots-fill fs-5"></i>
</button>

<div id="chat-widget" style="
position: fixed;
bottom: 80px;
right: 20px;
max-width: 360px;
width: 100%;
height: 480px;
display: none;
z-index: 1040;
transition: transform 0.3s ease;
background: white;
border-radius: 12px;
box-shadow: 0 5px 15px rgba(0,0,0,0.2);
">
<div class="card border-0 p-2 d-flex flex-column h-100 shadow">
<div class="d-flex justify-content-between align-items-center mb-1">
  <small class="text-muted fw-bold" id="chat-title">Jarvis</small>
  <div class="d-flex align-items-center gap-2">
    <button id="chat-history-btn" class="btn btn-primary" title="View Chat History" style="font-size: 1.2rem; min-width: 40px; height: 40px; display: flex !important; align-items: center; justify-content: center; background-color: #dc3545 !important; color: white !important; border-color: #dc3545 !important; margin-right: 8px; border-radius: 8px; box-shadow: 0 2px 4px rgba(220, 53, 69, 0.3);">
      <i class="bi bi-clock-history"></i>
    </button>
    <button id="switch-mode-btn" class="btn btn-sm btn-outline-primary p-1" style="display: none;" title="Switch to AI Chat">
      <i class="bi bi-robot"></i>
    </button>
    <button id="chat-close" class="btn btn-sm btn-outline-secondary p-1">
      <i class="bi bi-x-lg small"></i>
    </button>
  </div>
</div>

<!-- Chat Content -->
<div id="chat-container" class="flex-grow-1 bg-transparent rounded p-2 mb-1" style="overflow-y: auto; overflow-x: hidden;">
</div>

<!-- Chat History View (hidden by default) -->
<div id="chat-history-view" class="flex-grow-1 bg-transparent rounded p-2 mb-1" style="overflow-y: auto; overflow-x: hidden; display: none;">
  <div class="d-flex justify-content-between align-items-center mb-3">
    <h6 class="mb-0 text-muted">Recent Conversations</h6>
    <button id="back-to-chat-btn" class="btn btn-sm btn-outline-secondary p-1" title="Back to Chat">
      <i class="bi bi-arrow-left"></i>
    </button>
  </div>
  <div id="conversations-list" class="conversations-list">
    <!-- Conversations will be loaded here -->
  </div>
</div>

<!-- Modern Input Bar -->
<div class="input-bar position-relative">
  <button id="clear-btn" title="Clear Chat">
    <i class="bi bi-trash"></i>
  </button>

  <button id="upload-btn" title="Upload">
    <i class="bi bi-paperclip"></i>
  </button>
  <input type="file" id="file-input" accept=".pdf,.png,.jpg,.jpeg,.txt" hidden>

  <textarea id="query-input" placeholder="Ask anything" rows="1" autocomplete="off"></textarea>

  <!-- Inline predictive hint -->
  <span id="predictive-text" class="predictive ms-2"></span>

  <button id="ask-btn" title="Send">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-send-fill" viewBox="0 0 16 16">
          <path d="M15.964.686a.5.5 0 0 0-.65-.65L.767 5.855H.766l-.452.18a.5.5 0 0 0-.082.887l.41.26.001.002 4.995 3.178 3.178 4.995.002.002.26.41a.5.5 0 0 0 .886-.083zm-1.833 1.89L6.637 10.07l-.215-.338a.5.5 0 0 0-.154-.154l-.338-.215 7.494-7.494 1.178-.471z"/>
      </svg>
  </button>

  <!-- Stop button (hidden by default) -->
  <button id="stop-btn" title="Stop" style="display: none;">
      <i class="bi bi-stop-fill"></i>
  </button>
</div>
</div>
</div>

<style>
#chat-container img {
    max-width: 100%;
    height: auto;
    display: block;
    margin: 4px 0;
    border-radius: 4px;
}

.bubble {
    display: flex;
    width: 100%;
    padding: 0;
    margin: 0;
}

.bubble.justify-content-end {
    justify-content: flex-end;
}
.bubble.justify-content-start {
    justify-content: flex-start;
}

.bubble > div {
    max-width: 95%;
    min-width: 40px;
    word-break: break-word;
    border-radius: 1rem;
    box-shadow: 0 1px 2px rgba(0,0,0,0.04);
    margin: 0 2px;
    padding: 0.5rem 1rem;
}

.bubble .bg-primary {
    background-color: #0d6efd !important;
}

.bubble .bg-light {
    background-color: #f0f0f0 !important;
    color: #212529 !important; /* Ensure dark text */
}

.bubble .bg-secondary {
    color: #ffffff !important; /* ensure pending bubbles remain white text */
}

#chat-widget {
    background: white;
    border-radius: 12px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
}

#chat-toggle {
    background-color: #0d6efd !important;
    border: none;
    transition: transform 0.2s ease;
}

#chat-toggle:hover {
    transform: scale(1.1);
}

#chat-close {
    color: #666;
    transition: color 0.2s ease;
}

#chat-close:hover {
    color: #0d6efd;
}

#chat-container {
    height: calc(100% - 120px);
    padding: 1rem 0.5rem 1rem 0.5rem;
    background: white;
    overflow-y: auto;
    overflow-x: hidden; /* Prevent horizontal scroll caused by wide bubbles */
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.input-bar {
    display: flex;
    align-items: center;
    padding: 0.75rem;
    background-color: #40414f;
    border-radius: 1.25rem;
    border: 1px solid #2c2d39;
    margin-top: 0.5rem;
    gap: 0.5rem;
}

.input-bar textarea {
    flex-grow: 1;
    background: transparent;
    border: none;
    color: white;
    font-size: 0.95rem;
    line-height: 1.4;
    padding: 0.5rem 0.75rem;
    outline: none;
    resize: none;          /* Prevent manual drag – we resize via JS */
    overflow-y: hidden;    /* Hide scrollbar while auto-resizing */
    min-height: 36px;      /* Ensure placeholder is always visible */
}

.input-bar textarea::placeholder {
    font-size: 0.95rem;   /* Match actual text size to avoid jump */
    line-height: 1.4;      /* Keep same line-height */
    color: #8e8ea0;
}

.input-bar button {
    background: none;
    border: none;
    color: white;
    font-size: 1.2rem;
    cursor: pointer;
    padding: 0 0.3rem;
    transition: color 0.2s ease;
}

.input-bar button:hover {
    color: #0d6efd;
}

.thinking-dots .dot {
  opacity: 0.3;
  transition: opacity 0.2s;
  font-weight: bold;
  font-size: 1.2em;
}

/* ------------------------------------------------------------------ */
/* Stylish pending/thinking bubble                                   */
/* ------------------------------------------------------------------ */
.thinking-bubble {
    background: #6c757d !important; /* Matches Bootstrap secondary but allows shimmer */
    color: #fff !important;
    position: relative;
    overflow: hidden;
}

.thinking-bubble::after {
    content: '';
    position: absolute;
    top: 0;
    left: -150%;
    width: 50%;
    height: 100%;
    background: rgba(255, 255, 255, 0.15);
    transform: skewX(-20deg);
    animation: shimmer 1.75s infinite;
}

@keyframes shimmer {
    100% {
        left: 150%;
    }
}

/* Disabled states ------------------------------------------------------- */
.input-bar input[disabled] {
    background-color: transparent;
    color: white;
    cursor: not-allowed;
}

.input-bar button:disabled {
    opacity: 1;
    cursor: not-allowed;
}

/* Predictive inline hint */
.predictive {
    pointer-events: none;
    color: #8e8ea0;
    font-size: 0.9rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* ------------------------------------------------------------------ */
/* Upload progress bubble improvements                                */
/* ------------------------------------------------------------------ */
.progress-wrapper {
    width: 100%;          /* Ensure it never exceeds the bubble width */
    min-width: 160px;     /* Safe minimum so text wraps nicely         */
}

/* Override Bootstrap info bar with a subtle blue gradient */
.progress-bar.bg-info {
    background-image: linear-gradient(90deg, rgba(13,110,253,0.9), rgba(101,163,255,0.9));
}

/* Keep the animated stripes visible on dark backgrounds */
.progress-bar-striped.progress-bar-animated {
    background-size: 1rem 1rem;
}

/* Liquid animated gradient for progress bar */
@keyframes liquid-move {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

.progress-bubble {
    flex: 1 0 0;
    width: 100% !important;
    max-width: 100% !important;
    margin: 0 !important;
    padding: 0 !important;
    box-sizing: border-box;
    overflow: hidden; /* Ensures nothing spills out */
    background: none;
}

.progress-bubble .progress-wrapper {
    width: 100%;
    padding: 0;
    margin: 0;
}

.progress-bubble .progress {
    width: 100%;
    margin: 0;
    background: #e9ecef;
    border-radius: 8px;
    position: relative;
    overflow: hidden;
    box-shadow: none;
    height: 16px; /* Slightly taller for a more liquid look */
    display: flex;
    align-items: center;
}

.progress-bubble .progress-bar {
    height: 100%;
    border-radius: 0; /* Default: no radius for low progress */
    position: absolute;
    left: 0;
    top: 0;
    margin: 0;
    padding: 0;
    min-width: 0;
    z-index: 1;
    background: linear-gradient(270deg, #4f9dfd, #0d6efd, #4f9dfd, #0d6efd);
    background-size: 200% 100%;
    animation: liquid-move 3s ease infinite;
    color: #fff;
    box-shadow: 0 0 8px 2px rgba(13,110,253,0.15), 0 2px 8px rgba(79,157,253,0.10);
    transition: width 0.8s cubic-bezier(.22,1,.36,1), border-radius 0.2s;
}

/* Remove side margins for the row that hosts the progress bubble */
.progress-row {
    margin-left: 0 !important;
    margin-right: 0 !important;
}

/* Fancy gradient for primary progress bar */
.progress-bar.bg-primary {
    background-image: linear-gradient(90deg, #0d6efd, #4f9dfd);
}

/* Placeholder message styling */
.placeholder-message {
    opacity: 0.8;
    font-style: italic;
    transition: opacity 0.3s ease;
    margin: 2rem 0;
    color: #6c757d !important;
}

.placeholder-message:hover {
    opacity: 1;
}

.placeholder-message small {
    font-size: 0.9rem;
    letter-spacing: 0.5px;
}

.placeholder-message i {
    margin-right: 0.5rem;
    font-size: 1rem;
}

/* Chat History Styles */
.conversations-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.conversation-item {
    display: flex;
    align-items: center;
    padding: 0.75rem;
    background: #f8f9fa;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    border: 1px solid #e9ecef;
}

.conversation-item:hover {
    background: #e9ecef;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.conversation-item.active {
    background: #0d6efd;
    color: white;
}

.conversation-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: linear-gradient(135deg, #0d6efd, #4f9dfd);
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: bold;
    margin-right: 0.75rem;
    flex-shrink: 0;
}

.conversation-avatar.admin {
    background: linear-gradient(135deg, #dc3545, #fd7e14);
}

.conversation-content {
    flex: 1;
    min-width: 0;
}

.conversation-name {
    font-weight: 600;
    font-size: 0.9rem;
    margin-bottom: 0.25rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.conversation-preview {
    font-size: 0.8rem;
    color: #6c757d;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.conversation-item.active .conversation-preview {
    color: rgba(255,255,255,0.8);
}

.conversation-meta {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    margin-left: 0.5rem;
    flex-shrink: 0;
}

.conversation-time {
    font-size: 0.75rem;
    color: #6c757d;
    margin-bottom: 0.25rem;
}

.conversation-item.active .conversation-time {
    color: rgba(255,255,255,0.8);
}

.conversation-unread {
    background: #dc3545;
    color: white;
    border-radius: 50%;
    width: 18px;
    height: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.7rem;
    font-weight: bold;
}

.conversation-item.active .conversation-unread {
    background: rgba(255,255,255,0.2);
    color: white;
}

.empty-conversations {
    text-align: center;
    padding: 2rem 1rem;
    color: #6c757d;
}

.empty-conversations i {
    font-size: 2rem;
    margin-bottom: 1rem;
    opacity: 0.5;
}

.loading-conversations {
    text-align: center;
    padding: 1rem;
    color: #6c757d;
}

.loading-conversations .spinner-border {
    width: 1.5rem;
    height: 1.5rem;
}

/* Chat History Button Styling */
#chat-history-btn {
    font-size: 1.2rem !important;
    min-width: 40px !important;
    height: 40px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    background-color: #dc3545 !important;
    color: white !important;
    border-color: #dc3545 !important;
    margin-right: 8px !important;
    border-radius: 8px !important;
    box-shadow: 0 2px 4px rgba(220, 53, 69, 0.3) !important;
    transition: all 0.2s ease !important;
    opacity: 1 !important;
    visibility: visible !important;
    z-index: 1000 !important;
    position: relative !important;
}

#chat-history-btn:hover {
    background-color: #c82333 !important;
    border-color: #c82333 !important;
    transform: scale(1.1) !important;
    box-shadow: 0 4px 12px rgba(220, 53, 69, 0.5) !important;
}

#chat-history-btn:active {
    transform: scale(0.95) !important;
}

/* Ensure button is always visible and prominent */
#chat-history-btn {
    opacity: 1 !important;
    visibility: visible !important;
    display: flex !important;
    position: relative !important;
}

/* Make sure the button container doesn't hide it */
.d-flex.align-items-center.gap-2 {
    display: flex !important;
    align-items: center !important;
    gap: 0.5rem !important;
}

/* Add pulsing animation to draw attention */
@keyframes pulse-red {
    0% { 
        transform: scale(1); 
        box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); 
    }
    70% { 
        transform: scale(1.05); 
        box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); 
    }
    100% { 
        transform: scale(1); 
        box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); 
    }
}

#chat-history-btn {
    animation: pulse-red 2s infinite;
}
</style>

<script>
// Chat functionality
let chatMessages = [];
let isLoadingHistory = false;
const MAX_LENGTH = 1000;
const MAX_MESSAGES = 50;

// Chat mode management
let currentChatMode = 'ai'; // 'ai', 'user', or 'history'
let currentChatUser = null; // { username: string, userId: string }
let userChatHistory = new Map(); // Store chat history for different users
let conversations = []; // Store loaded conversations

// Track current abort controller so we can cancel in-flight requests ------
let currentAbortController = null;

/* ------------------------------------------------------------------ */
/* Global textarea auto
rezise helper                              */
/* ------------------------------------------------------------------ */
const MIN_TEXTAREA_HEIGHT = 36; // px – keep placeholder visible
function autoResize() {
    const el = document.getElementById('query-input');
    if (!el) return;
    // Reset height to auto so scrollHeight reflects current content
    el.style.height = 'auto';
    const newHeight = Math.max(el.scrollHeight, MIN_TEXTAREA_HEIGHT);
    el.style.height = `${newHeight}px`;
}

function saveMessage(who, html, isHtml) {
    chatMessages.push({
        who,
        html: isHtml && typeof html === 'string' ? html.slice(0, MAX_LENGTH) : html,
        isHtml
    });
    if (chatMessages.length > MAX_MESSAGES) {
        chatMessages = chatMessages.slice(-MAX_MESSAGES);
    }
    
    // Save to appropriate storage based on chat mode
    try {
        if (currentChatMode === 'ai') {
            localStorage.setItem('chatMessages', JSON.stringify(chatMessages));
        } else if (currentChatMode === 'user' && currentChatUser) {
            const userKey = `userChat_${currentChatUser.userId}`;
            userChatHistory.set(userKey, [...chatMessages]);
            localStorage.setItem(userKey, JSON.stringify(chatMessages));
        }
    } catch (e) {
        console.warn('Failed to save chatMessages:', e);
    }
}

function appendMessage(who, content, isHtml = false, pending = false) {
    const container = document.getElementById('chat-container');
    if (!container) return null;

    // Remove placeholder message if it exists when adding any message
    const placeholder = container.querySelector('.placeholder-message');
    if (placeholder) {
        placeholder.remove();
    }

    const wrapper = document.createElement('div');
    wrapper.classList.add('d-flex', 'mb-2', 'bubble',
        who === 'user' ? 'justify-content-end' : 'justify-content-start'
    );
    const bubble = document.createElement('div');
    bubble.classList.add('p-2', 'rounded');

    if (who === 'user') {
        bubble.classList.add('bg-primary', 'text-white');
    } else if (pending) {
        bubble.classList.add('bg-secondary', 'text-white');
    } else {
        bubble.classList.add('bg-light', 'text-dark');
    }

    if (isHtml) bubble.innerHTML = content;
    else bubble.textContent = content;

    wrapper.appendChild(bubble);
    container.appendChild(wrapper);
    container.scrollTop = container.scrollHeight;

    // Save to chat history if not pending and not loading history
    if (!pending && !isLoadingHistory) {
        saveMessage(who, content, isHtml);
        
        // If this is a user message, trigger real-time update
        if (who === 'user') {
            // Emit socket event for real-time updates
            if (typeof socket !== 'undefined') {
                socket.emit('chat_message', {
                    user: document.body.getAttribute('data-username') || 'Anonymous',
                    question: content,
                    timestamp: new Date().toISOString()
                });
            }
        }
    }
    return bubble;
}

async function loadMessageHistory() {
    const container = document.getElementById('chat-container');
    let stored = null;
    
    if (currentChatMode === 'ai') {
        stored = localStorage.getItem('chatMessages');
        if (!stored) {
            const usernameAttr = document.body.getAttribute('data-username') || '';
            const greeting = usernameAttr ? `Hello ${usernameAttr}! How may I assist you today?` : 'Hello! How may I assist you today?';
            appendMessage('bot', greeting, false);
            return true;
        }
    } else if (currentChatMode === 'user' && currentChatUser) {
        const userKey = `userChat_${currentChatUser.userId}`;
        stored = localStorage.getItem(userKey);
        if (!stored) {
            // Add a placeholder message that will be removed after first message
            const placeholder = document.createElement('div');
            placeholder.classList.add('text-center', 'text-muted', 'py-3', 'placeholder-message');
            placeholder.innerHTML = '<small><i class="bi bi-chat-dots"></i> The start of a great conversation...</small>';
            if (container) {
                container.appendChild(placeholder);
            }
            return true;
        }
    }
    
    try {
        isLoadingHistory = true;
        chatMessages = JSON.parse(stored).slice(-MAX_MESSAGES);
        chatMessages.forEach(m => appendMessage(m.who, m.html, m.isHtml));
        container.scrollTop = container.scrollHeight;
        return true;
    } catch {
        return false;
    } finally {
        isLoadingHistory = false;
    }
}

function appendThinkingBubble() {
    const container = document.getElementById('chat-container');
    if (!container) return null;
    const wrapper = document.createElement('div');
    wrapper.classList.add('d-flex', 'mb-2', 'bubble', 'justify-content-start');
    const bubble = document.createElement('div');
    bubble.classList.add('p-2', 'rounded', 'bg-secondary', 'text-white', 'thinking-bubble');
    bubble.innerHTML = `
      <span class="spinner-border spinner-border-sm me-2" role="status"></span>
      <span class="thinking-dots">Thinking<span class="dot">.</span><span class="dot">.</span><span class="dot">.</span></span>
    `;
    wrapper.appendChild(bubble);
    container.appendChild(wrapper);
    container.scrollTop = container.scrollHeight;
    // Animate dots
    let dotIndex = 0;
    const dots = bubble.querySelectorAll('.dot');
    const interval = setInterval(() => {
      dots.forEach((d, i) => d.style.opacity = (i === dotIndex % 3) ? '1' : '0.3');
      dotIndex++;
    }, 400);
    bubble._thinkingInterval = interval;
    return bubble;
}

// Use relative path so requests hit the same origin Flask backend – this
// guarantees chat conversations are recorded server-side and broadcast in
// real-time via Socket.IO.
const JARVIS_ENDPOINT = '/ai/jarvis';
// Call Cloudflare Worker directly from the browser (bypasses Flask).
const SPARK_ENDPOINT = 'https://spark.oscarsolis3301.workers.dev/jarvis';

async function sendQuestion(queryInput) {
    if (currentAbortController) return; // Prevent concurrent requests
    const q = queryInput.value.trim();
    if (!q) return;

    // UI elements needed for enable/disable
    const askBtn = document.getElementById('ask-btn');
    const uploadBtn = document.getElementById('upload-btn');
    const fileInput = document.getElementById('file-input');
    const stopBtn = document.getElementById('stop-btn');
    const predictiveText = document.getElementById('predictive-text');

    // Restrict user input while processing
    function setUiBusy(busy) {
        queryInput.disabled = busy;
        askBtn.style.display = busy ? 'none' : 'inline';
        stopBtn.style.display = busy ? 'inline' : 'none';
        uploadBtn.disabled = busy;
        fileInput.disabled = busy;
        if (!busy) {
            queryInput.focus();
        }
    }

    setUiBusy(true);
    queryInput.value = '';
    autoResize();
    appendMessage('user', q);

    // Handle different chat modes
    if (currentChatMode === 'user' && currentChatUser) {
        // User-to-user messaging
        await sendUserMessage(q, currentChatUser);
        setUiBusy(false);
        return;
    }

    // AI chat mode (existing logic)

    // Show animated thinking bubble
    const pending = appendThinkingBubble();

    // Start timer to measure round-trip latency
    const startTime = performance.now();

    // Prepare abort controller & stop handler
    const abortController = new AbortController();
    currentAbortController = abortController;
    stopBtn.onclick = () => abortController.abort();

    let data;
    try {
        // 1️⃣ PRIMARY – ask our backend (DB/local LLM). This is fast when the
        // answer already exists, and we avoid a Cloudflare call.
        const dbResponse = await fetch(JARVIS_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ question: q, db_only: true }),
            signal: abortController.signal
        });

        if (dbResponse.ok) {
            data = await dbResponse.json();
            if (data && data.answer && data.answer.trim()) {
                // Found in DB – done.
            } else {
                throw new Error('No answer in database');
            }
        } else {
            throw new Error('Database lookup failed');
        }
    } catch (dbError) {
        console.warn('DB lookup failed or empty – falling back to Spark:', dbError);
        try {
            // 2️⃣ Cloudflare Spark fallback (client-side to bypass server DNS)
            const sparkResponse = await fetch(SPARK_ENDPOINT, {
                method: 'POST',
                mode: 'cors',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ inputs: [{ prompt: q }] }),
                signal: abortController.signal
            });

            if (!sparkResponse.ok) {
                throw new Error(`Spark endpoint error: ${sparkResponse.status}`);
            }

            const sparkData = await sparkResponse.json();
            if (!Array.isArray(sparkData) || !sparkData.length || !sparkData[0].response) {
                throw new Error('Invalid response from Cloudflare');
            }

            data = { answer: sparkData[0].response, sources: [] };

            // Asynchronously store in our DB – new lightweight *store-only* path
            fetch(JARVIS_ENDPOINT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ question: q, answer: data.answer })
            }).catch(() => {});

        } catch (sparkError) {
            console.error('Spark endpoint error:', sparkError);
            throw new Error('I\'m sorry, I wasn\'t able to reach the cloud AI service right now. Please try again later.');
        }
    }

    try {
        // Compute elapsed time and append badge to the answer
        const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
        const answerHtml = buildAnswerHtml(data);
        const answerWithTime = `${answerHtml}<div class="small mt-1 text-danger">⏱ ${elapsed}s</div>`;
        
        if (pending) {
            displayAnswer(pending, answerWithTime);
        }
    } catch (error) {
        console.error('Error:', error);
        if (pending) {
            clearInterval(pending._thinkingInterval);
            pending.classList.replace('bg-secondary', 'bg-light');
            pending.classList.replace('text-white', 'text-dark');
            pending.textContent = error.name === 'AbortError' ?
                'Request canceled.' :
                error.message || 'Sorry, I encountered an error. Please try again.';
        }
    } finally {
        currentAbortController = null;
        setUiBusy(false);
    }
}

// User-to-user messaging function
async function sendUserMessage(message, user) {
    try {
        // Send message to the user via API
        const response = await fetch('/api/private-messages/messages', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                recipient_id: user.userId === 'admin' ? 1 : parseInt(user.userId) || 1,
                message: message
            })
        });

        if (response.ok) {
            const result = await response.json();
                    if (result.success) {
            // Emit socket event for real-time updates
            if (typeof socket !== 'undefined') {
                socket.emit('private_message', {
                    recipient_id: user.userId === 'admin' ? 1 : parseInt(user.userId) || 1,
                    message: message,
                    timestamp: new Date().toISOString()
                });
            }
        } else {
            appendMessage('bot', `Failed to send message: ${result.error}`, false);
        }
        } else {
            appendMessage('bot', 'Failed to send message. Please try again.', false);
        }
    } catch (error) {
        console.error('Error sending user message:', error);
        appendMessage('bot', 'Error sending message. Please try again.', false);
    }
}

// Add file handling function
async function handleFile(file) {
    if (currentAbortController) return; // Prevent concurrent requests
    if (!file) return;

    // UI elements needed for enable/disable
    const queryInput = document.getElementById('query-input');
    const askBtn = document.getElementById('ask-btn');
    const uploadBtn = document.getElementById('upload-btn');
    const fileInput = document.getElementById('file-input');
    const stopBtn = document.getElementById('stop-btn');
    const predictiveText = document.getElementById('predictive-text');

    function setUiBusy(busy) {
        queryInput.disabled = busy;
        askBtn.style.display = busy ? 'none' : 'inline';
        stopBtn.style.display = busy ? 'inline' : 'none';
        uploadBtn.disabled = busy;
        fileInput.disabled = busy;
        if (!busy) {
            queryInput.focus();
        }
    }

    setUiBusy(true);

    // Show file in chat ---------------------------------------------------
    const isImage = file.type.startsWith('image/');
    const display = isImage
        ? `<img src="${URL.createObjectURL(file)}" alt="${file.name}" style="max-width: 200px;">`
        : `<div class="file-attachment">
             <i class="bi bi-file-earmark-text me-2"></i>
             ${file.name}
           </div>`;
    appendMessage('user', display, true);

    // ------------------------------------------------------------------
    // Progress bubble: shows stage + percentage bar that we update while
    // the backend is processing the file.
    // ------------------------------------------------------------------
    const progressHtml = `
        <div class="progress-wrapper w-100 p-2">
            <div class="small mb-1 fw-semibold progress-stage">Extracting text...</div>
            <div class="progress" style="height: 8px; border-radius: 4px;">
              <div class="progress-bar progress-bar-striped progress-bar-animated bg-primary" role="progressbar" style="width: 0%;"></div>
            </div>
            <div class="small text-end progress-percentage mt-1">0%</div>
        </div>`;

    const pending = appendMessage('bot', progressHtml, true, true);
    if (pending) {
        // Mark this bubble so CSS can force full-width layout
        pending.classList.add('progress-bubble');
        const row = pending.parentElement;
        if (row) row.classList.add('progress-row');
    }

    // Simulated incremental progress until server responds ---------------
    let progress = 0;
    const stages = ['Extracting text...', 'Summarizing...'];
    let stageIdx = 0;
    const progressInterval = setInterval(() => {
        if (!pending) return;
        const increment = Math.max(0.5, (95 - progress) * 0.02);
        progress = Math.min(progress + increment, 95);
        const bar = pending.querySelector('.progress-bar');
        const perc = pending.querySelector('.progress-percentage');
        const stageElem = pending.querySelector('.progress-stage');
        if (bar) {
            bar.style.width = `${progress.toFixed(1)}%`;
            // Border radius logic for perfect fill:
            if (progress >= 99.5) {
                bar.style.borderRadius = '8px'; // Fully rounded at 100%
            } else if (progress >= 5) {
                bar.style.borderRadius = '8px 0 0 8px'; // Rounded left only
            } else {
                bar.style.borderRadius = '0'; // No radius at very low progress
            }
        }
        if (perc) perc.textContent = `${progress.toFixed(1)}%`;
        if (stageElem && progress > (stageIdx + 1) * 33) {
            stageIdx = Math.min(stageIdx + 1, stages.length - 1);
            stageElem.textContent = stages[stageIdx];
        }
    }, 50); // More frequent updates for smoother animation

    // ----------------------------------------------
    // Start timer for file-based AI processing
    // ----------------------------------------------
    const startTime = performance.now();

    // Prepare abort controller & stop handler
    const abortController = new AbortController();
    currentAbortController = abortController;
    stopBtn.onclick = () => abortController.abort();

    try {
        const formData = new FormData();
        formData.append('file', file);

        const response = await fetch(JARVIS_ENDPOINT, {
            method: 'POST',
            body: formData,
            signal: abortController.signal
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
        const answerHtml = buildAnswerHtml(data);
        const answerWithTime = `${answerHtml}<div class="small mt-1 text-danger">⏱ ${elapsed}s</div>`;

        // Complete progress bar ------------------------------------------------
        if (pending) {
            clearInterval(progressInterval);
            const bar = pending.querySelector('.progress-bar');
            const perc = pending.querySelector('.progress-percentage');
            const stageElem = pending.querySelector('.progress-stage');
            if (bar) {
                bar.style.width = '100%';
                bar.style.borderRadius = '8px';
            }
            if (perc) perc.textContent = '100%';
            if (stageElem) stageElem.textContent = 'Completed';

            // Smooth transition to final answer
            pending.style.transition = 'opacity 0.3s ease';
            pending.style.opacity = '0';
            setTimeout(() => {
                displayAnswer(pending, answerWithTime);
                pending.style.opacity = '1';
            }, 300);
        }
    } catch (error) {
        console.error('Error uploading file:', error);
        if (pending) {
            clearInterval(progressInterval);
            pending.classList.replace('bg-secondary', 'bg-light');
            pending.classList.replace('text-white', 'text-dark');
            pending.innerHTML = error.name === 'AbortError' ?
                'Request canceled.' :
                'Sorry, I encountered an error processing your file. Please try again.';
        }
    } finally {
        currentAbortController = null;
        clearInterval(progressInterval);
        setUiBusy(false);
    }
}

// Add file upload styling
const fileUploadStyle = document.createElement('style');
fileUploadStyle.textContent = `
.file-attachment {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    background: rgba(13, 110, 253, 0.1);
    border-radius: 8px;
    font-size: 0.9em;
}

.file-attachment i {
    font-size: 1.2em;
    margin-right: 8px;
}
`;
document.head.appendChild(fileUploadStyle);

// Initialize chat when DOM is loaded
window.addEventListener('load', async function() {
    console.log('Initializing chat widget...');
    
    // Add a small delay to ensure all elements are properly loaded
    setTimeout(() => {
        console.log('Chat widget elements check:', {
            chatToggle: !!document.getElementById('chat-toggle'),
            chatWidget: !!document.getElementById('chat-widget'),
            chatContainer: !!document.getElementById('chat-container'),
            queryInput: !!document.getElementById('query-input')
        });
    }, 100);

// Also initialize on DOMContentLoaded as backup
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOMContentLoaded - checking chat elements');
    const chatToggle = document.getElementById('chat-toggle');
    const chatWidget = document.getElementById('chat-widget');
    
    if (chatToggle && chatWidget) {
        console.log('Chat elements found on DOMContentLoaded');
    } else {
        console.error('Chat elements missing on DOMContentLoaded');
    }
});
    
    const container = document.getElementById('chat-container');
    const queryInput = document.getElementById('query-input');
    const askBtn = document.getElementById('ask-btn');
    const uploadBtn = document.getElementById('upload-btn');
    const fileInput = document.getElementById('file-input');
    const chatToggle = document.getElementById('chat-toggle');
    const chatWidget = document.getElementById('chat-widget');
    const chatClose = document.getElementById('chat-close');
    const clearBtn = document.getElementById('clear-btn');
    const stopBtn = document.getElementById('stop-btn');
    const predictiveText = document.getElementById('predictive-text');
    const switchModeBtn = document.getElementById('switch-mode-btn');
    const chatTitle = document.getElementById('chat-title');
    const chatHistoryBtn = document.getElementById('chat-history-btn');
    const backToChatBtn = document.getElementById('back-to-chat-btn');

    // Verify all elements exist
    if (!container || !queryInput || !askBtn || !uploadBtn || !fileInput || 
        !chatToggle || !chatWidget || !chatClose || !clearBtn || !stopBtn || !predictiveText ||
        !switchModeBtn || !chatTitle || !chatHistoryBtn || !backToChatBtn) {
        console.error('Some chat elements are missing:', {
            container: !!container,
            queryInput: !!queryInput,
            askBtn: !!askBtn,
            uploadBtn: !!uploadBtn,
            fileInput: !!fileInput,
            chatToggle: !!chatToggle,
            chatWidget: !!chatWidget,
            chatClose: !!chatClose,
            clearBtn: !!clearBtn,
            stopBtn: !!stopBtn,
            predictiveText: !!predictiveText,
            switchModeBtn: !!switchModeBtn,
            chatTitle: !!chatTitle,
            chatHistoryBtn: !!chatHistoryBtn,
            backToChatBtn: !!backToChatBtn
        });
        return;
    }

    // Initialize chat widget state
    chatWidget.style.display = 'none';
    console.log('Chat widget initialized');

    // Ensure default AI mode is set
    currentChatMode = 'ai';
    currentChatUser = null;
    
    // Load message history
    await loadMessageHistory();

    // Send question handlers ------------------------------------------------
    askBtn.onclick = () => sendQuestion(queryInput);

    // Auto-grow whenever the user types ----------------------------------
    // Initialise size once on load using global helper
    autoResize();
    queryInput.addEventListener('input', autoResize);

    queryInput.onkeydown = (e) => {
        if (e.key === 'Tab' || e.key === 'ArrowRight') {
            // Accept suggestion without sending
            if (predictiveText.textContent) {
                e.preventDefault();
                queryInput.value += predictiveText.textContent;
                predictiveText.textContent = '';
                autoResize();
            }
        } else if (e.key === 'Enter' && !e.shiftKey) {
            // Press Enter to send – Shift+Enter inserts newline
            e.preventDefault();
            // If a suggestion is visible, append it before sending
            if (predictiveText.textContent) {
                queryInput.value += predictiveText.textContent;
                predictiveText.textContent = '';
            }
            sendQuestion(queryInput);
        }
    };

    // File upload handlers
    if (uploadBtn && fileInput) {
        uploadBtn.onclick = () => fileInput.click();
        
        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
                e.target.value = ''; // Clear the input
            }
        };

        // Add drag and drop support
        chatWidget.ondragover = (e) => {
            e.preventDefault();
            e.stopPropagation();
            chatWidget.style.border = '2px dashed #0d6efd';
        };

        chatWidget.ondragleave = (e) => {
            e.preventDefault();
            e.stopPropagation();
            chatWidget.style.border = 'none';
        };

        chatWidget.ondrop = (e) => {
            e.preventDefault();
            e.stopPropagation();
            chatWidget.style.border = 'none';
            
            const file = e.dataTransfer.files[0];
            if (file) {
                handleFile(file);
            }
        };

        // Add paste support
        document.onpaste = (e) => {
            const items = e.clipboardData?.items;
            for (let i = 0; items && i < items.length; i++) {
                if (items[i].kind === 'file') {
                    const file = items[i].getAsFile();
                    if (file) {
                        handleFile(file);
                        break;
                    }
                }
            }
        };
    }

    // Chat toggle handlers
    chatToggle.onclick = function() {
        console.log('Chat toggle clicked - main handler');
        console.log('Chat widget display state:', chatWidget.style.display);
        console.log('Current chat mode:', currentChatMode);
        const isHidden = chatWidget.style.display === 'none';
        
        if (isHidden) {
            // Opening the chat widget
            chatWidget.style.display = 'block';
            chatToggle.innerHTML = '<i class="bi bi-x-lg fs-5"></i>';
            
            // Ensure we're in AI mode when opening
            if (currentChatMode !== 'ai') {
                switchToAIMode();
            }
            
            // Ensure we're in chat view (not history view)
            const chatHistoryView = document.getElementById('chat-history-view');
            if (chatHistoryView && chatHistoryView.style.display !== 'none') {
                switchToChatView();
            }
            
            // Ensure chat history button is visible
            if (chatHistoryBtn) {
                chatHistoryBtn.style.display = 'flex';
                chatHistoryBtn.style.visibility = 'visible';
                chatHistoryBtn.style.opacity = '1';
                chatHistoryBtn.style.backgroundColor = '#dc3545';
                chatHistoryBtn.style.color = 'white';
                chatHistoryBtn.style.borderColor = '#dc3545';
                chatHistoryBtn.style.fontSize = '1.2rem';
                chatHistoryBtn.style.minWidth = '40px';
                chatHistoryBtn.style.height = '40px';
                console.log('Chat history button made visible');
            }
            
            // Scroll to bottom and focus input
            if (container) {
                container.scrollTop = container.scrollHeight;
            }
            if (queryInput) {
                queryInput.focus();
            }
        } else {
            // Closing the chat widget
            chatWidget.style.display = 'none';
            chatToggle.innerHTML = '<i class="bi bi-chat-dots-fill fs-5"></i>';
        }
    };

    // Close button handler
    chatClose.onclick = function() {
        console.log('Chat close clicked');
        chatWidget.style.display = 'none';
        chatToggle.innerHTML = '<i class="bi bi-chat-dots-fill fs-5"></i>';
    };

    // Clear chat handler
    clearBtn.onclick = function() {
        console.log('Clear chat clicked');
        chatMessages = [];
        if (currentChatMode === 'ai') {
            localStorage.removeItem('chatMessages');
            container.innerHTML = '';
            appendMessage('bot', 'How may I assist you today?', false);
        } else if (currentChatMode === 'user' && currentChatUser) {
            const userKey = `userChat_${currentChatUser.userId}`;
            localStorage.removeItem(userKey);
            userChatHistory.delete(userKey);
            container.innerHTML = '';
            chatMessages = [];
            // Add placeholder message for empty user chat
            const placeholder = document.createElement('div');
            placeholder.classList.add('text-center', 'text-muted', 'py-3', 'placeholder-message');
            placeholder.innerHTML = '<small><i class="bi bi-chat-dots"></i> The start of a great conversation...</small>';
            container.appendChild(placeholder);
        }
    };

    // Switch mode handler
    switchModeBtn.onclick = function() {
        console.log('Switch mode clicked');
        if (currentChatMode === 'user') {
            switchToAIMode();
        } else {
            switchToUserMode(currentChatUser);
        }
    };

    // Chat history button handler
    chatHistoryBtn.onclick = function() {
        console.log('Chat history button clicked');
        switchToHistoryView();
    };
    
    // Debug: Log button visibility
    console.log('Chat history button found:', !!chatHistoryBtn);
    if (chatHistoryBtn) {
        console.log('Chat history button styles:', window.getComputedStyle(chatHistoryBtn));
        console.log('Chat history button display:', chatHistoryBtn.style.display);
        console.log('Chat history button visibility:', chatHistoryBtn.style.visibility);
        console.log('Chat history button opacity:', chatHistoryBtn.style.opacity);
        
        // Force the button to be visible
        chatHistoryBtn.style.display = 'flex';
        chatHistoryBtn.style.visibility = 'visible';
        chatHistoryBtn.style.opacity = '1';
        chatHistoryBtn.style.backgroundColor = '#dc3545';
        chatHistoryBtn.style.color = 'white';
        chatHistoryBtn.style.borderColor = '#dc3545';
        chatHistoryBtn.style.fontSize = '1.2rem';
        chatHistoryBtn.style.minWidth = '40px';
        chatHistoryBtn.style.height = '40px';
        
        // Add a more prominent highlight to make the button impossible to miss
        setTimeout(() => {
            chatHistoryBtn.style.transform = 'scale(1.3)';
            chatHistoryBtn.style.boxShadow = '0 0 30px rgba(220, 53, 69, 0.8)';
            chatHistoryBtn.style.zIndex = '9999';
            setTimeout(() => {
                chatHistoryBtn.style.transform = 'scale(1)';
                chatHistoryBtn.style.boxShadow = '0 2px 4px rgba(220, 53, 69, 0.3)';
            }, 2000);
        }, 500);
        
        console.log('Chat history button forced to be visible');
    } else {
        console.error('Chat history button not found!');
    }

    // Back to chat button handler
    backToChatBtn.onclick = function() {
        console.log('Back to chat button clicked');
        switchToChatView();
    };

    // Debounced prediction fetch ---------------------------------------
    let predictTimeout;
    queryInput.addEventListener('input', () => {
        predictiveText.textContent = '';
        clearTimeout(predictTimeout);
        const val = queryInput.value.trim();
        // Only predict after user has typed at least TWO tokens (contains space)
        if (!val.includes(' ')) return;
        predictTimeout = setTimeout(() => fetchPrediction(val), 200);
    });

    function fetchPrediction(q) {
        fetch(`/ai/suggest?q=${encodeURIComponent(q)}`)
            .then(r => r.json())
            .then(({ suggestions }) => {
                if (!Array.isArray(suggestions) || !suggestions.length) { predictiveText.textContent = ''; return; }
                const first = suggestions[0];
                if (first.toLowerCase().startsWith(q.toLowerCase()) && first.length > q.length) {
                    predictiveText.textContent = first.slice(q.length);
                } else {
                    predictiveText.textContent = '';
                }
            }).catch(() => { predictiveText.textContent = ''; });
    }

    console.log('Chat widget setup complete');

    // Setup socket event listeners for private messages
    if (typeof socket !== 'undefined') {
        // Listen for private messages
        socket.on('private_message', (data) => {
            console.log('Received private message:', data);
            // Only show if we're in user mode and it's from the current chat user
            if (currentChatMode === 'user' && currentChatUser && 
                (data.sender_id == currentChatUser.userId || data.recipient_id == currentChatUser.userId)) {
                const isFromOtherUser = data.sender_id != currentChatUser.userId;
                if (isFromOtherUser) {
                    appendMessage('bot', data.message, false);
                }
            }
        });

        // Listen for private message sent confirmation
        socket.on('private_message_sent', (data) => {
            console.log('Private message sent confirmation:', data);
        });

        // Listen for private chat history
        socket.on('private_chat_history', (data) => {
            console.log('Received private chat history:', data);
            if (data.messages && data.messages.length > 0) {
                // Clear current messages and load history
                container.innerHTML = '';
                chatMessages = [];
                data.messages.forEach(msg => {
                    const isFromCurrentUser = msg.sender_id == (currentChatUser ? currentChatUser.userId : null);
                    appendMessage(isFromCurrentUser ? 'user' : 'bot', msg.message, false);
                });
            } else {
                // If no messages, add placeholder
                const placeholder = document.createElement('div');
                placeholder.classList.add('text-center', 'text-muted', 'py-3', 'placeholder-message');
                placeholder.innerHTML = '<small><i class="bi bi-chat-dots"></i> The start of a great conversation...</small>';
                container.appendChild(placeholder);
            }
        });

        // Listen for typing indicators
        socket.on('private_typing', (data) => {
            console.log('Private typing indicator:', data);
            // Could add typing indicator UI here
        });

        // Listen for read receipts
        socket.on('private_messages_read', (data) => {
            console.log('Messages marked as read:', data);
        });

        // Listen for errors
        socket.on('error', (data) => {
            console.error('Socket error:', data);
            if (data.message) {
                appendMessage('bot', `Error: ${data.message}`, false);
            }
        });
    }

    // Add fallback event listener for chat toggle
    document.addEventListener('click', (e) => {
        if (e.target.closest('#chat-toggle')) {
            console.log('Chat toggle clicked via fallback listener');
            const isHidden = chatWidget.style.display === 'none';
            
            if (isHidden) {
                chatWidget.style.display = 'block';
                chatToggle.innerHTML = '<i class="bi bi-x-lg fs-5"></i>';
                
                // If we're not in AI mode, switch to AI mode
                if (currentChatMode !== 'ai') {
                    switchToAIMode();
                }
                
                // Ensure we're in chat view (not history view)
                const chatHistoryView = document.getElementById('chat-history-view');
                if (chatHistoryView && chatHistoryView.style.display !== 'none') {
                    switchToChatView();
                }
                
                // Ensure chat history button is visible
                const chatHistoryBtn = document.getElementById('chat-history-btn');
                if (chatHistoryBtn) {
                    chatHistoryBtn.style.display = 'flex';
                    chatHistoryBtn.style.visibility = 'visible';
                    chatHistoryBtn.style.opacity = '1';
                    chatHistoryBtn.style.backgroundColor = '#dc3545';
                    chatHistoryBtn.style.color = 'white';
                    chatHistoryBtn.style.borderColor = '#dc3545';
                    chatHistoryBtn.style.fontSize = '1.2rem';
                    chatHistoryBtn.style.minWidth = '40px';
                    chatHistoryBtn.style.height = '40px';
                    console.log('Chat history button made visible (fallback)');
                }
                
                if (container) {
                    container.scrollTop = container.scrollHeight;
                }
                if (queryInput) {
                    queryInput.focus();
                }
            } else {
                chatWidget.style.display = 'none';
                chatToggle.innerHTML = '<i class="bi bi-chat-dots-fill fs-5"></i>';
            }
        }
    });

    // Delegate click on summary-toggle buttons -------------------------
    document.addEventListener('click', (e) => {
        const btn = e.target.closest('.summary-toggle');
        if (!btn) return;
        const bubble = btn.closest('p');
        const preview = bubble.querySelector('.summary-preview');
        const full = bubble.querySelector('.summary-full');
        if (!preview || !full) return;
        const expanded = !full.classList.contains('d-none');
        if (expanded) {
            // Collapse
            full.classList.add('d-none');
            preview.classList.remove('d-none');
            btn.textContent = 'Show more';
        } else {
            // Expand
            full.classList.remove('d-none');
            preview.classList.add('d-none');
            btn.textContent = 'Show less';
        }
    });
});

// Chat mode switching functions
function switchToUserMode(user) {
    if (!user) return;
    
    currentChatMode = 'user';
    currentChatUser = user;
    
    // Update UI
    const chatTitle = document.getElementById('chat-title');
    const switchModeBtn = document.getElementById('switch-mode-btn');
    const queryInput = document.getElementById('query-input');
    
    chatTitle.textContent = user.username;
    switchModeBtn.style.display = 'inline';
    switchModeBtn.innerHTML = '<i class="bi bi-robot"></i>';
    switchModeBtn.title = 'Switch to AI Chat';
    queryInput.placeholder = `Message ${user.username}...`;
    
    // Clear current chat and load user chat history
    const container = document.getElementById('chat-container');
    container.innerHTML = '';
    chatMessages = [];
    
    // Join private chat room via socket
    if (typeof socket !== 'undefined') {
        socket.emit('join_private_chat', {
            other_user_id: user.userId === 'admin' ? 1 : parseInt(user.userId) || 1
        });
    }
    
    // Load user chat history
    loadMessageHistory();
    
    // Ensure placeholder is shown if no messages exist
    setTimeout(() => {
        const existingMessages = container.querySelectorAll('.bubble');
        const existingPlaceholder = container.querySelector('.placeholder-message');
        if (existingMessages.length === 0 && !existingPlaceholder) {
            const placeholder = document.createElement('div');
            placeholder.classList.add('text-center', 'text-muted', 'py-3', 'placeholder-message');
            placeholder.innerHTML = '<small><i class="bi bi-chat-dots"></i> The start of a great conversation...</small>';
            container.appendChild(placeholder);
        }
    }, 100);
    
    // If we're coming from history view, switch back to chat view
    const chatHistoryView = document.getElementById('chat-history-view');
    if (chatHistoryView && chatHistoryView.style.display !== 'none') {
        switchToChatView();
    }
}

function switchToAIMode() {
    // Leave private chat room if we were in user mode
    if (currentChatMode === 'user' && currentChatUser && typeof socket !== 'undefined') {
        socket.emit('leave_private_chat', {
            other_user_id: currentChatUser.userId === 'admin' ? 1 : parseInt(currentChatUser.userId) || 1
        });
    }
    
    currentChatMode = 'ai';
    currentChatUser = null;
    
    // Update UI
    const chatTitle = document.getElementById('chat-title');
    const switchModeBtn = document.getElementById('switch-mode-btn');
    const queryInput = document.getElementById('query-input');
    
    if (chatTitle) chatTitle.textContent = 'Jarvis';
    if (switchModeBtn) switchModeBtn.style.display = 'none';
    if (queryInput) queryInput.placeholder = 'Ask anything';
    
    // Clear current chat and load AI chat history
    const container = document.getElementById('chat-container');
    if (container) {
        container.innerHTML = '';
        chatMessages = [];
        
        // Load AI chat history
        loadMessageHistory();
    }
    
    // If we're coming from history view, switch back to chat view
    const chatHistoryView = document.getElementById('chat-history-view');
    if (chatHistoryView && chatHistoryView.style.display !== 'none') {
        switchToChatView();
    }
}

// Global function to open chat in user mode (called from YAM.html)
window.openUserChat = function(username, userId) {
    const chatWidget = document.getElementById('chat-widget');
    const chatToggle = document.getElementById('chat-toggle');
    
    // Switch to user mode
    switchToUserMode({ username, userId });
    
    // Show chat widget
    chatWidget.style.display = 'block';
    chatToggle.innerHTML = '<i class="bi bi-x-lg fs-5"></i>';
    
    // Focus on input
    const queryInput = document.getElementById('query-input');
    if (queryInput) {
        queryInput.focus();
    }
};

// Chat history functions
async function loadConversations() {
    const conversationsList = document.getElementById('conversations-list');
    if (!conversationsList) return;
    
    // Show loading state
    conversationsList.innerHTML = `
        <div class="loading-conversations">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <div class="mt-2">Loading conversations...</div>
        </div>
    `;
    
    try {
        const response = await fetch('/api/private-messages/conversations');
        if (response.ok) {
            const data = await response.json();
            if (data.success) {
                conversations = data.conversations || [];
                displayConversations(conversations);
            } else {
                throw new Error(data.error || 'Failed to load conversations');
            }
        } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
    } catch (error) {
        console.error('Error loading conversations:', error);
        conversationsList.innerHTML = `
            <div class="empty-conversations">
                <i class="bi bi-exclamation-triangle"></i>
                <div>Failed to load conversations</div>
                <small class="text-muted">${error.message}</small>
            </div>
        `;
    }
}

function displayConversations(conversations) {
    const conversationsList = document.getElementById('conversations-list');
    if (!conversationsList) return;
    
    if (!conversations || conversations.length === 0) {
        conversationsList.innerHTML = `
            <div class="empty-conversations">
                <i class="bi bi-chat-dots"></i>
                <div>No conversations yet</div>
                <small class="text-muted">Start a conversation to see it here</small>
            </div>
        `;
        return;
    }
    
    const conversationsHtml = conversations.map(conv => {
        const otherUser = conv.other_user;
        const isAdmin = otherUser.username.toLowerCase() === 'admin';
        const avatarClass = isAdmin ? 'admin' : '';
        const avatarText = otherUser.username.charAt(0).toUpperCase();
        
        // Format time
        const messageTime = new Date(conv.last_message_at);
        const timeAgo = formatTimeAgo(messageTime);
        
        // Create conversation item
        return `
            <div class="conversation-item" data-user-id="${otherUser.id}" data-username="${otherUser.username}">
                <div class="conversation-avatar ${avatarClass}">${avatarText}</div>
                <div class="conversation-content">
                    <div class="conversation-name">${otherUser.username}</div>
                    <div class="conversation-preview">Click to continue conversation</div>
                </div>
                <div class="conversation-meta">
                    <div class="conversation-time">${timeAgo}</div>
                    ${conv.unread_count > 0 ? `<div class="conversation-unread">${conv.unread_count}</div>` : ''}
                </div>
            </div>
        `;
    }).join('');
    
    conversationsList.innerHTML = conversationsHtml;
    
    // Add click handlers to conversation items
    conversationsList.querySelectorAll('.conversation-item').forEach(item => {
        item.addEventListener('click', () => {
            const userId = item.dataset.userId;
            const username = item.dataset.username;
            
            // Switch to user mode with this conversation
            switchToUserMode({ username, userId });
            
            // Switch back to chat view
            switchToChatView();
        });
    });
}

function formatTimeAgo(date) {
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    if (diffMins < 1) return 'Just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;
    
    return date.toLocaleDateString();
}

function switchToHistoryView() {
    currentChatMode = 'history';
    
    // Update UI
    const chatTitle = document.getElementById('chat-title');
    const chatContainer = document.getElementById('chat-container');
    const chatHistoryView = document.getElementById('chat-history-view');
    const inputBar = document.querySelector('.input-bar');
    
    if (chatTitle) chatTitle.textContent = 'Chat History';
    if (chatContainer) chatContainer.style.display = 'none';
    if (chatHistoryView) chatHistoryView.style.display = 'block';
    if (inputBar) inputBar.style.display = 'none';
    
    // Load conversations
    loadConversations();
}

function switchToChatView() {
    // Hide history view, show chat view
    const chatContainer = document.getElementById('chat-container');
    const chatHistoryView = document.getElementById('chat-history-view');
    const inputBar = document.querySelector('.input-bar');
    
    if (chatHistoryView) chatHistoryView.style.display = 'none';
    if (chatContainer) chatContainer.style.display = 'block';
    if (inputBar) inputBar.style.display = 'flex';
    
    // Update title based on current mode
    const chatTitle = document.getElementById('chat-title');
    if (chatTitle) {
        if (currentChatMode === 'ai') {
            chatTitle.textContent = 'Jarvis';
        } else if (currentChatMode === 'user' && currentChatUser) {
            chatTitle.textContent = currentChatUser.username;
        }
    }
}

// Helper to reveal answer with typing effect and correct styles ------------
function displayAnswer(bubble, answerHtml) {
    if (!bubble) return;

    // Stop spinner / dot animation
    if (bubble._thinkingInterval) {
        clearInterval(bubble._thinkingInterval);
        delete bubble._thinkingInterval;
    }

    // Reset classes for standard bot bubble and force dark text
    bubble.classList.remove('thinking-bubble', 'bg-secondary', 'text-white');
    bubble.classList.add('bg-light', 'text-dark');
    bubble.style.color = '#212529';

    // Typing effect --------------------------------------------------------
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = answerHtml;
    const fullText = tempDiv.textContent || tempDiv.innerText || '';

    // If answer contains rich HTML (e.g., <code>, <ul>, images) show instantly
    const isPlainText = fullText.trim() === answerHtml.trim();

    if (!isPlainText) {
        bubble.innerHTML = answerHtml;
        // Ensure newest content is visible
        const container = document.getElementById('chat-container');
        if (container) container.scrollTop = container.scrollHeight;
        saveMessage('bot', answerHtml, true);
        return;
    }

    // Plain-text: animate typing
    bubble.innerHTML = '';
    let idx = 0;
    const typeInterval = setInterval(() => {
        bubble.textContent += fullText.charAt(idx);
        idx++;
        if (idx >= fullText.length) {
            clearInterval(typeInterval);
            const container = document.getElementById('chat-container');
            if (container) container.scrollTop = container.scrollHeight;
            saveMessage('bot', answerHtml, false);
        }
    }, 20); // 50 chars/sec
}

// Build answer HTML with optional sources ----------------------------------
function buildAnswerHtml(data) {
    if (!data) return 'Sorry, I couldn\'t process your request. Please try again.';
    
    // Handle both database and spark response formats
    const answer = data.answer || data.response || '';
    if (!answer) {
        return 'Sorry, I couldn\'t generate a response. Please try again.';
    }
    
    const sources = data.sources || [];
    
    let html = answer;
    
    // Add sources if available
    if (Array.isArray(sources) && sources.length) {
        const links = sources.map(s => {
            const title = s.title || s.url;
            const url = s.url;
            return `<li><a href="${url}" target="_blank">${title}</a></li>`;
        }).join('');
        html += `<hr /><div class="mt-2"><strong>Related resources:</strong><ul>${links}</ul></div>`;
    }
    
    return html;
}
</script>
</body>
</html>